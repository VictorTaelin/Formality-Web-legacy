/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/formality-lang/compiler.js":
/*!*************************************************!*\
  !*** ./node_modules/formality-lang/compiler.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {Var, App, Lam, erase, gen_name, show} = __webpack_require__(/*! ./formality.js */ \"./node_modules/formality-lang/formality.js\");\nconst {Net, Pointer, Node} = __webpack_require__(/*! ./nasic.js */ \"./node_modules/formality-lang/nasic.js\");\n\nconst compile = (term, defs = {}) => {\n  const build_net = (term, net, var_ptrs, level) => {\n    const get_var = (ptr) => {\n      if (!net.enter_port(ptr) || net.enter_port(ptr).equal(ptr)) {\n        return ptr;\n      } else {\n        var dups_ptr = net.enter_port(ptr);\n        var dup_addr = net.alloc_node(Math.floor((1 + Math.random()) * Math.pow(2,16)));\n        net.link_ports(new Pointer(dup_addr, 0), ptr);\n        net.link_ports(new Pointer(dup_addr, 1), dups_ptr);\n        return new Pointer(dup_addr, 2);\n      }\n    };\n    switch (term[0]) {\n      case \"Dup\":\n        var expr_ptr = build_net(term[1].expr, net, var_ptrs, level);\n        var_ptrs.push(expr_ptr);\n        var body_ptr = build_net(term[1].body, net, var_ptrs, level);\n        var_ptrs.pop();\n        return body_ptr;\n      case \"Put\":\n        var expr_ptr = build_net(term[1].expr, net, var_ptrs, level + 1);\n        return expr_ptr;\n      case \"Lam\":\n        var lam_addr = net.alloc_node(1);\n        net.link_ports(new Pointer(lam_addr, 1), new Pointer(lam_addr, 1));\n        var_ptrs.push(new Pointer(lam_addr, 1));\n        var body_ptr = build_net(term[1].body, net, var_ptrs, level);\n        var_ptrs.pop();\n        net.link_ports(new Pointer(lam_addr, 2), body_ptr);\n        return new Pointer(lam_addr, 0);\n      case \"App\":\n        var app_addr = net.alloc_node(1);\n        var func_ptr = build_net(term[1].func, net, var_ptrs, level);\n        net.link_ports(new Pointer(app_addr, 0), func_ptr);\n        var argm_ptr = build_net(term[1].argm, net, var_ptrs, level);\n        net.link_ports(new Pointer(app_addr, 1), argm_ptr)\n        return new Pointer(app_addr, 2);\n      case \"Var\":\n        return get_var(var_ptrs[var_ptrs.length - term[1].index - 1]);\n      case \"Ref\":\n        return build_net(erase(defs[term[1].name]), net, var_ptrs, level);\n      default:\n        return build_net(Lam(\"\", null, Var(0)), net, var_ptrs, level);\n    }\n  };\n  var level_of = {};\n  var net = new Net();\n  var root_addr = net.alloc_node(0);\n  var term_ptr = build_net(erase(term), net, [], 0);\n  net.link_ports(new Pointer(root_addr, 0), new Pointer(root_addr, 2));\n  net.link_ports(new Pointer(root_addr, 1), term_ptr);\n  // Removes invalid redexes. They can be created by the\n  // compiler when duplicating variables more than once.\n  net.redex = net.redex.filter(([a_addr, b_addr]) => {\n    var a_p0 = new Pointer(a_addr, 0);\n    var b_p0 = new Pointer(b_addr, 0);\n    var a_ok = net.enter_port(a_p0).equal(b_p0);\n    var b_ok = net.enter_port(b_p0).equal(a_p0);\n    return a_ok && b_ok;\n  });\n  return net;\n};\n\nconst decompile = (net) => {\n  const build_term = (net, ptr, var_ptrs, dup_exit) => {\n    var label = net.nodes[ptr.addr].label;\n    if (label === 1) {\n      switch (ptr.port) {\n        case 0:\n          var_ptrs.push(new Pointer(ptr.addr, 1));\n          var body = build_term(net, net.enter_port(new Pointer(ptr.addr, 2)), var_ptrs, dup_exit);\n          var_ptrs.pop();\n          return Lam(gen_name(var_ptrs.length), null, body);\n        case 1:\n          for (var index = 0; index < var_ptrs.length; ++index) {\n            if (var_ptrs[var_ptrs.length - index - 1].equal(ptr)) {\n              return Var(index);\n            }\n          }\n        case 2:\n          var argm = build_term(net, net.enter_port(new Pointer(ptr.addr, 1)), var_ptrs, dup_exit);\n          var func = build_term(net, net.enter_port(new Pointer(ptr.addr, 0)), var_ptrs, dup_exit);\n          return App(func, argm);\n      }\n    } else {\n      switch (ptr.port) {\n        case 0:\n          var exit = dup_exit.pop();\n          var term = build_term(net, net.enter_port(new Pointer(ptr.addr, exit)), var_ptrs, dup_exit);\n          dup_exit.push(exit);\n          return term;\n        default:\n          dup_exit.push(ptr.port);\n          var term = build_term(net, net.enter_port(new Pointer(ptr.addr, 0)), var_ptrs, dup_exit);\n          dup_exit.pop();\n          return term;\n      }\n    }\n  };\n  return build_term(net, net.enter_port(new Pointer(0, 1)), [], []);\n};\n\nconst norm_with_stats = (term, defs = {}, lazy = true) => {\n  var net = compile(term, defs);\n  var stats = lazy ? net.reduce_lazy() : net.reduce();\n  var norm = decompile(net);\n  return {norm, stats};\n};\n\nconst norm = (term, defs, lazy) => {\n  return norm_with_stats(term, defs, lazy).norm;\n};\n\nmodule.exports = {compile, decompile, norm_with_stats, norm};\n\n\n//# sourceURL=webpack:///./node_modules/formality-lang/compiler.js?");

/***/ }),

/***/ "./node_modules/formality-lang/formality.js":
/*!**************************************************!*\
  !*** ./node_modules/formality-lang/formality.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const Var = (index)                  => [\"Var\", {index},                  \"[\" + index + \"]\"];\nconst Typ = ()                       => [\"Typ\", {},                       \"#typ\"];\nconst All = (name, bind, body, eras) => [\"All\", {name, bind, body, eras}, \"#all\" + bind[2] + body[2]];\nconst Lam = (name, bind, body, eras) => [\"Lam\", {name, bind, body, eras}, \"#lam\" + (bind?bind[2]:\"\") + body[2]];\nconst App = (func, argm, eras)       => [\"App\", {func, argm, eras},       \"#app\" + func[2] + argm[2]];\nconst Ref = (name, eras)             => [\"Ref\", {name, eras},             \"{\" + name + \"}\"];\nconst Box = (expr)                   => [\"Box\", {expr},                   \"#box\" + expr[2]];\nconst Put = (expr)                   => [\"Put\", {expr},                   \"#put\" + expr[2]];\nconst Dup = (name, expr, body)       => [\"Dup\", {name, expr, body},       \"#dup\" + expr[2] + body[2]];\nconst Slf = (name, type)             => [\"Slf\", {name, type},             \"#slf\" + type[2]];\nconst New = (type, expr)             => [\"New\", {type, expr},             \"#new\" + type[2] + expr[2]];\nconst Use = (expr)                   => [\"Use\", {expr},                   \"#use\" + expr[2]];\nconst Ann = (type, expr, done)       => [\"Ann\", {type, expr, done},       \"#ann\" + expr[2] + type[2]];\n\n// Generates a name\nconst gen_name = (n) => {\n  var str = \"\";\n  ++n;\n  while (n > 0) {\n    --n;\n    str += String.fromCharCode(97 + n % 26);\n    n = Math.floor(n / 26);\n  }\n  return str;\n};\n\n\nconst Ctx = () => null;\n\nconst extend = (ctx, bind) => {\n  return {head: bind, tail: ctx};\n}\n\nconst len = (ctx) => {\n  return ctx ? 1 + ctx.tail : 0;\n}\n\nconst get_bind = (ctx, i, j = 0) => {\n  if (!ctx) {\n    return null;\n  } else if (j < i) {\n    return get_bind(ctx.tail, i, j + 1);\n  } else {\n    return [ctx.head[0], ctx.head[1] ? shift(ctx.head[1], i, 0) : null];\n  }\n}\n\nconst get_name = (ctx, i) => {\n  const count = (ctx, name, i) => {\n    return i === 0 ? 0 : (ctx.head[0] === name ? 1 : 0) + count(ctx.tail, name, i - 1);\n  }\n  const repeat = (str, i) => {\n    return i === 0 ? \"\" : str + repeat(str, i - 1);\n  }\n  var bind = get_bind(ctx, i);\n  if (bind) {\n    return (bind[0] || \"x\") + repeat(\"'\", count(ctx, bind[0], i));\n  } else {\n    return \"#\" + i;\n  }\n}\n\nconst get_term = (ctx, i) => {\n  return get_bind(ctx, i) ? get_bind(ctx, i)[1] : null;\n}\n\nconst index_of = (ctx, name, skip, i = 0) => {\n  if (!ctx) {\n    return null;\n  } else if (ctx.head[0] === name && skip > 0) {\n    return index_of(ctx.tail, name, skip - 1, i + 1);\n  } else if (ctx.head[0] !== name) {\n    return index_of(ctx.tail, name, skip, i + 1);\n  } else {\n    return i;\n  }\n}\n\n// Pretty prints a context\nconst show_context = (ctx, i = 0) => {\n  var bind = get_bind(ctx, i);\n  if (bind) {\n    var term = \" : \" + (bind[1] ? show(norm(bind[1], {}), ctx) : \"?\");\n    return show_context(ctx, i + 1) + bind[0] + term + \"\\n\";\n  } else {\n    return \"\";\n  }\n}\n\n// Converts a term to a string\nconst show = ([ctor, args], ctx = Ctx()) => {\n  switch (ctor) {\n    case \"Var\":\n      var name = get_name(ctx, args.index);\n      return name !== null ? name : \"#\" + args.index;\n    case \"Typ\":\n      return \"Type\";\n    case \"All\":\n      var eras = args.eras ? \"-\" : \"\";\n      var name = args.name || \"x\";\n      var bind = show(args.bind, ctx);\n      var body = show(args.body, extend(ctx, [args.name, null]));\n      return \"{\" + eras + name + \" : \" + bind + \"} \" + body;\n    case \"Lam\":\n      var eras = args.eras ? \"-\" : \"\";\n      var name = args.name || \"x\";\n      var bind = args.bind && show(args.bind, ctx);\n      var body = show(args.body, extend(ctx, [name, null]));\n      return bind ? \"[\" + eras + name + \" : \" + bind + \"] \" + body : \"[\" + eras + name + \"] \" + body;\n    case \"App\":\n      var text = \")\";\n      var term = [ctor, args];\n      while (term[0] === \"App\") {\n        text = (term[1].eras ? \" -\" : \" \") + show(term[1].argm, ctx) + text;\n        term = term[1].func;\n      }\n      return \"(\" + show(term, ctx) + text;\n    case \"Box\":\n      var expr = show(args.expr, ctx);\n      return \"!\" + expr;\n    case \"Put\":\n      var expr = show(args.expr, ctx);\n      return \"|\" + expr;\n    case \"Dup\":\n      var name = args.name;\n      var expr = show(args.expr, ctx);\n      var body = show(args.body, extend(ctx, [args.name, null]));\n      return \"[\" + name + \" = \" + expr + \"] \" + body;\n    case \"Slf\":\n      var name = args.name;\n      var type = show(args.type, extend(ctx, [args.name, null]));\n      return \"$\" + name + \" \" + type;\n    case \"New\":\n      var type = show(args.type, ctx);\n      var expr = show(args.expr, ctx);\n      return \"@\" + type + \" \" + expr;\n    case \"Use\":\n      var expr = show(args.expr, ctx);\n      return \"~\" + expr; \n    case \"Ann\":\n      //var type = show(args.type, ctx);\n      //var expr = show(args.expr, ctx);\n      //return \":\" + type + \" = \" + expr;\n      //var type = show(args.type, ctx);\n      var expr = show(args.expr, ctx);\n      return expr;\n    case \"Ref\":\n      return args.name;\n  }\n}\n\n// Converts a string to a term\nconst parse = (code) => {\n  function is_space(char) {\n    return char === \" \" || char === \"\\t\" || char === \"\\n\";\n  }\n\n  function is_name_char(char) {\n    return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_.~\".indexOf(char) !== -1;\n  }\n\n  function skip_spaces() {\n    while (index < code.length && is_space(code[index])) {\n      index += 1;\n    }\n    return index;\n  }\n\n  function match(string) {\n    skip_spaces();\n    var sliced = code.slice(index, index + string.length);\n    if (sliced === string) {\n      index += string.length;\n      return true;\n    }\n    return false;\n  }\n\n  function error(text) {\n    text += \"This is the relevant code:\\n\\n<<<\";\n    text += code.slice(index - 64, index) + \"<<<HERE>>>\";\n    text += code.slice(index, index + 64) + \">>>\";\n    throw text;\n  }\n\n  function parse_exact(string) {\n    if (!match(string)) {\n      error(\"Parse error, expected '\" + string + \"'.\\n\");\n    }\n  }\n\n  function parse_name() {\n    skip_spaces();\n    var name = \"\";\n    while (index < code.length && is_name_char(code[index])) {\n      name = name + code[index];\n      index += 1;\n    }\n    return name;\n  }\n\n  function parse_term(ctx) {\n    // Comment\n    if (match(\"//\")) {\n      while (index < code.length && code[index] !== \"\\n\") {\n        index += 1;\n      }\n      return parse_term(ctx);\n    }\n\n    // Application\n    else if (match(\"(\")) {\n      var func = parse_term(ctx);\n      while (index < code.length && !match(\")\")) {\n        var eras = match(\"-\");\n        var argm = parse_term(ctx);\n        var func = App(func, argm, eras);\n        skip_spaces();\n      }\n      return func;\n    }\n\n    // Type\n    else if (match(\"Type\")) {\n      return Typ();\n    }\n\n    // Forall\n    else if (match(\"{\")) {\n      var eras = match(\"-\");\n      var name = parse_name();\n      var skip = parse_exact(\":\");\n      var bind = parse_term(ctx);\n      var skip = parse_exact(\"}\");\n      var body = parse_term(extend(ctx, [name, Var(0)]));\n      return All(name, bind, body, eras);\n    }\n\n    // Lambda\n    else if (match(\"[\")) {\n      var eras = match(\"-\");\n      var name = parse_name();\n      var bind = match(\":\") ? parse_term(ctx) : null;\n      var expr = match(\"=\") ? parse_term(ctx) : null;\n      var skip = parse_exact(\"]\");\n      var body = parse_term(extend(ctx, [name, Var(0)]));\n      return expr ? Dup(name, expr, body) : Lam(name, bind, body, eras);\n    }\n\n    // Box\n    else if (match(\"!\")) {\n      var expr = parse_term(ctx);\n      return Box(expr);\n    }\n\n    // Put\n    else if (match(\"|\")) {\n      var expr = parse_term(ctx);\n      return Put(expr);\n    }\n\n    // Let\n    else if (match(\"let\")) {\n      var name = parse_name();\n      var copy = parse_term(ctx);\n      var body = parse_term(extend(ctx, [name, Var(0)]));\n      return subst(body, copy, 0);\n    }\n\n    // Slf\n    else if (match(\"$\")) {\n      var name = parse_name();\n      var type = parse_term(extend(ctx, [name, Var(0)]));\n      return Slf(name, type);\n    }\n\n    // New\n    else if (match(\"@\")) {\n      var type = parse_term(ctx);\n      var expr = parse_term(ctx);\n      return New(type, expr);\n    }\n\n    // Use\n    else if (match(\"~\")) {\n      var expr = parse_term(ctx);\n      return Use(expr);\n    }\n\n    // Ann\n    else if (match(\":\")) {\n      var type = parse_term(ctx);\n      var skip = parse_exact(\"=\");\n      var expr = parse_term(ctx);\n      return Ann(type, expr, false);\n    }\n\n    // Variable / Reference\n    else {\n      var name = parse_name();\n      var skip = 0;\n      while (match(\"'\")) {\n        skip += 1;\n      }\n      var var_index = index_of(ctx, name, skip);\n      if (var_index === null) {\n        return Ref(name, false);\n      } else {\n        return get_bind(ctx, var_index)[1];\n      }\n    }\n  }\n\n  var index = 0;\n  var defs = {};\n  while (index < code.length) {\n    skip_spaces();\n    if (match(\"//\")) {\n      while (index < code.length && code[index] !== \"\\n\") {\n        index += 1;\n      }\n    } else {\n      var skip = parse_exact(\".\");\n      var name = parse_name();\n      var term = parse_term(Ctx());\n      defs[name] = term;\n    }\n    skip_spaces();\n  }\n\n  return defs;\n}\n\n// Shifts a term\nconst shift = ([ctor, term], inc, depth) => {\n  switch (ctor) {\n    case \"Var\":\n      return Var(term.index < depth ? term.index : term.index + inc);\n    case \"Typ\":\n      return Typ();\n    case \"All\":\n      var eras = term.eras;\n      var name = term.name;\n      var bind = shift(term.bind, inc, depth);\n      var body = shift(term.body, inc, depth + 1);\n      return All(name, bind, body, eras);\n    case \"Lam\":\n      var eras = term.eras;\n      var name = term.name;\n      var bind = term.bind && shift(term.bind, inc, depth);\n      var body = shift(term.body, inc, depth + 1);\n      return Lam(name, bind, body, eras);\n    case \"App\":\n      var eras = term.eras;\n      var func = shift(term.func, inc, depth);\n      var argm = shift(term.argm, inc, depth);\n      return App(func, argm, eras);\n    case \"Box\":\n      var expr = shift(term.expr, inc, depth);\n      return Box(expr);\n    case \"Put\":\n      var expr = shift(term.expr, inc, depth);\n      return Put(expr);\n    case \"Dup\":\n      var name = term.name;\n      var expr = shift(term.expr, inc, depth);\n      var body = shift(term.body, inc, depth + 1);\n      return Dup(name, expr, body);\n    case \"Slf\":\n      var name = term.name;\n      var type = shift(term.type, inc, depth + 1);\n      return Slf(name, type);\n    case \"New\":\n      var type = shift(term.type, inc, depth);\n      var expr = shift(term.expr, inc, depth);\n      return New(type, expr);\n    case \"Use\":\n      var expr = shift(term.expr, inc, depth);\n      return Use(expr);\n    case \"Ann\":\n      var type = shift(term.type, inc, depth);\n      var expr = shift(term.expr, inc, depth);\n      var done = term.done;\n      return Ann(type, expr, done);\n    case \"Ref\":\n      return Ref(term.name, term.eras);\n  }\n}\n\n// Substitution\nconst subst = ([ctor, term], val, depth) => {\n  switch (ctor) {\n    case \"Var\":\n      return depth === term.index ? val : Var(term.index - (term.index > depth ? 1 : 0));\n    case \"Typ\":\n      return Typ();\n    case \"All\":\n      var eras = term.eras;\n      var name = term.name;\n      var bind = subst(term.bind, val, depth);\n      var body = subst(term.body, val && shift(val, 1, 0), depth + 1);\n      return All(name, bind, body, eras);\n    case \"Lam\":\n      var eras = term.eras;\n      var name = term.name;\n      var bind = term.bind && subst(term.bind, val, depth);\n      var body = subst(term.body, val && shift(val, 1, 0), depth + 1);\n      return Lam(name, bind, body, eras);\n    case \"App\":\n      var eras = term.eras;\n      var func = subst(term.func, val, depth);\n      var argm = subst(term.argm, val, depth);\n      return App(func, argm, eras);\n    case \"Box\":\n      var expr = subst(term.expr, val, depth);\n      return Box(expr);\n    case \"Put\":\n      var expr = subst(term.expr, val, depth);\n      return Put(expr);\n    case \"Dup\": \n      var name = term.name;\n      var expr = subst(term.expr, val, depth);\n      var body = subst(term.body, val && shift(val, 1, 0), depth + 1);\n      return Dup(name, expr, body);\n    case \"Slf\":\n      var name = term.name;\n      var type = subst(term.type, val && shift(val, 1, 0), depth + 1);\n      return Slf(name, type);\n    case \"New\":\n      var type = subst(term.type, val, depth);\n      var expr = subst(term.expr, val, depth);\n      return New(type, expr);\n    case \"Use\":\n      var expr = subst(term.expr, val, depth);\n      return Use(expr);\n    case \"Ann\":\n      var type = subst(term.type, val, depth);\n      var expr = subst(term.expr, val, depth);\n      var done = term.done;\n      return Ann(type, expr, done);\n    case \"Ref\":\n      var eras = term.eras;\n      var name = term.name;\n      return Ref(name, eras);\n  }\n}\n\n\n// How many times a variable was used in computational positions\nconst uses = ([ctor, term], depth = 0) => {\n  switch (ctor) {\n    case \"Var\": return term.index === depth ? 1 : 0;\n    case \"Typ\": return 0;\n    case \"All\": return 0;\n    case \"Lam\": return uses(term.body, depth + 1);\n    case \"App\": return uses(term.func, depth) + (!term.eras ? uses(term.argm, depth) : 0);\n    case \"Box\": return uses(term.expr, depth);\n    case \"Put\": return uses(term.expr, depth);\n    case \"Dup\": return uses(term.expr, depth) + uses(term.body, depth + 1);\n    case \"Slf\": return 0;\n    case \"New\": return uses(term.expr, depth);\n    case \"Use\": return uses(term.expr, depth);\n    case \"Ann\": return uses(term.expr, depth);\n    case \"Ref\": return 0;\n  }\n}\n\n// Checks if variable only occurs at a specific relative level\nconst is_at_level = ([ctor, term], at_level, depth = 0, level = 0) => {\n  switch (ctor) {\n    case \"Var\": return term.index !== depth || level === at_level;\n    case \"Typ\": return true;\n    case \"All\": return true;\n    case \"Lam\": return is_at_level(term.body, at_level, depth + 1, level);\n    case \"App\": return is_at_level(term.func, at_level, depth, level) && (term.eras || is_at_level(term.argm, at_level, depth, level));\n    case \"Box\": return is_at_level(term.expr, at_level, depth, level);\n    case \"Put\": return is_at_level(term.expr, at_level, depth, level + 1);\n    case \"Dup\": return is_at_level(term.expr, at_level, depth, level) + is_at_level(term.body, at_level, depth + 1, level);\n    case \"Slf\": return true;\n    case \"New\": return is_at_level(term.expr, at_level, depth, level);\n    case \"Use\": return is_at_level(term.expr, at_level, depth, level);\n    case \"Ann\": return is_at_level(term.expr, at_level, depth, level);\n    case \"Ref\": return true;\n  }\n}\n          \n// Removes computationally irrelevant expressions\nconst erase = ([ctor, args]) => {\n  switch (ctor) {\n    case \"Var\": return Var(args.index);\n    case \"Typ\": return Typ();\n    case \"All\": return All(args.name, erase(args.bind), erase(args.body), args.eras);\n    case \"Lam\": return args.eras ? subst(erase(args.body), Typ(), 0) : Lam(args.name, null, erase(args.body), args.eras);\n    case \"App\": return args.eras ? erase(args.func) : App(erase(args.func), erase(args.argm), args.eras);\n    case \"Box\": return Box(erase(args.expr));\n    case \"Put\": return Put(erase(args.expr));\n    case \"Dup\": return Dup(args.name, erase(args.expr), erase(args.body));\n    case \"Ref\": return Ref(args.name, true);\n    case \"Slf\": return Slf(args.name, erase(args.type));\n    case \"New\": return erase(args.expr);\n    case \"Use\": return erase(args.expr);\n    case \"Ann\": return erase(args.expr);\n  }\n}\n\n// Checks if two terms are equal\nconst equals = (a, b, defs) => {\n  const Eqs = (a, b)    => [\"Eqs\", {a, b}];\n  const Bop = (v, x, y) => [\"Bop\", {v, x, y}];\n  const Val = (v)       => [\"Val\", {v}];\n\n  const step = (node) => {\n    switch (node[0]) {\n      // An equality test\n      case \"Eqs\":\n        var {a, b} = node[1];\n\n        // Gets whnfs with and without dereferencing\n        var ax = norm(a, {}, true);\n        var bx = norm(b, {}, true);\n        var ay = norm(a, defs, true);\n        var by = norm(b, defs, true);\n\n        // Optional optimization: if hashes are equal, then a == b\n        if (a[2] === b[2] || ax[2] === bx[2] || ay[2] === by[2]) {\n          return Val(true);\n        }\n\n        // If non-deref whnfs are app and fields are equal, then a == b\n        var x = null;\n        if (ax[2] !== ay[2] || bx[2] !== by[2]) {\n          if (ax[0] === \"Ref\" && bx[0] === \"Ref\" && ax[1].name === bx[1].name) {\n            x = Val(true);\n          } else if (ax[0] === \"App\" && bx[0] === \"App\") {\n            var func = Eqs(ax[1].func, bx[1].func);\n            var argm = Eqs(ax[1].argm, bx[1].argm);\n            x = Bop(false, func, argm);\n          }\n        }\n\n        // If whnfs are equal and fields are equal, then a == b\n        var y = null;\n        if (ay[0] === \"Typ\" && by[0] === \"Typ\") {\n          y = Val(true);\n        } else if (ay[0] === \"All\" && by[0] === \"All\") {\n          y = Bop(false, Eqs(ay[1].bind, by[1].bind), Eqs(ay[1].body, by[1].body));\n        } else if (ay[0] === \"Lam\" && by[0] === \"Lam\") {\n          y = Eqs(ay[1].body, by[1].body)\n        } else if (ay[0] === \"App\" && by[0] === \"App\") {\n          y = Bop(false, Eqs(ay[1].func, by[1].func), Eqs(ay[1].argm, by[1].argm));\n        } else if (ay[0] === \"Var\" && by[0] === \"Var\") {\n          y = Val(ay[1].index === by[1].index);\n        } else if (ay[0] === \"Box\" && by[0] === \"Box\") {\n          y = Eqs(ay[1].expr, by[1].expr);\n        } else if (ay[0] === \"Put\" && by[0] === \"Put\") {\n          y = Eqs(ay[1].expr, by[1].expr);\n        } else if (ay[0] === \"Dup\" && by[0] === \"Dup\") {\n          y = Bop(false, Eqs(ay[1].expr, by[1].expr), Eqs(ay[1].body, by[1].body));\n        } else if (ay[0] === \"Slf\" && by[0] === \"Slf\") {\n          y = Eqs(ay[1].type, by[1].type);\n        } else if (ay[0] === \"Eqs\" && by[0] === \"Eqs\") {\n          y = Bop(false, Eqs(ay[1].val0, by[1].val0), Eqs(ay[1].val1, by[1].val1));\n        } else {\n          y = Val(false);\n        }\n\n        return x ? Bop(true, x, y) : y;\n\n      // A binary operation (or / and)\n      case \"Bop\":\n        var {v, x, y} = node[1];\n        if (x[0] === \"Val\") {\n          return x[1].v === v ? Val(v) : y;\n        } else if (y[0] === \"Val\") {\n          return y[1].v === v ? Val(v) : x;\n        } else {\n          return Bop(v, step(x), step(y));\n        }\n\n      // A result value (true / false)\n      case \"Val\":\n        return node;\n    }\n  }\n\n  // Expands the search tree until it finds an answer\n  var tree = Eqs(erase(a), erase(b));\n  while (tree[0] !== \"Val\") {\n    var tree = step(tree);\n  }\n  return tree[1].v;\n}\n\n// Reduces a term to normal form or head normal form\nconst norm = (foo, defs = {}, weak = false, dup = false) => {\n  const [ctor, term] = foo;\n  const cont = !weak ? norm : (x => x);\n  const apply = (eras, func, argm) => {\n    var func = norm(func, defs, true, dup);\n    // ([x]a b) ~> [b/x]a\n    if (func[0] === \"Lam\") {\n      return norm(subst(func[1].body, argm, 0), defs, weak, dup);\n    // ([x = a] b c) ~> [x = a] (b c)\n    } else if (func[0] === \"Dup\") {\n      return cont(Dup(func[1].name, func[1].expr, App(func[1].body, shift(argm, 1, 0), eras)), defs, weak, dup);\n    } else {\n      return App(cont(func, defs, weak, dup), cont(argm, defs, eras || weak, dup), eras);\n    }\n  }\n  const duplicate = (name, expr, body) => {\n    var expr = norm(expr, defs, true, dup);\n    // [x = |a] b ~> [a/x]b\n    if (expr[0] === \"Put\") {\n      return norm(subst(body, expr[1].expr, 0), defs, weak, dup);\n    // [x = [y = a] b] c ~> [y = a] [x = b] c\n    } else if (expr[0] === \"Dup\") {\n      return cont(Dup(expr[1].name, expr[1].expr, Dup(name, expr[1].body, shift(body, 1, 1))), dup);\n    } else {\n      return Dup(name, cont(expr, defs, weak, dup), cont(body, defs, weak, dup));\n    }\n  }\n  const dereference = (eras, name) => {\n    if (defs[name]) {\n      var nf = norm(defs[name], defs, weak, dup);\n      return eras ? erase(nf) : nf;\n    } else {\n      return Ref(name, eras);\n    }\n  }\n  switch (ctor) {\n    case \"Var\": return Var(term.index);\n    case \"Typ\": return Typ();\n    case \"All\": return All(term.name, cont(term.bind, defs, true, dup), cont(term.body, defs, weak, dup), term.eras);\n    case \"Lam\": return Lam(term.name, term.bind && cont(term.bind, defs, true, dup), cont(term.body, defs, weak, dup), term.eras); \n    case \"App\": return apply(term.eras, term.func, term.argm);\n    case \"Box\": return Box(cont(term.expr, defs, weak, dup));\n    case \"Put\": return dup ? norm(term.expr, defs, weak, dup) : Put(cont(term.expr, defs, weak, dup));\n    case \"Dup\": return dup ? norm(subst(term.body, term.expr, 0), defs, weak, dup) : duplicate(term.name, term.expr, term.body);\n    case \"Slf\": return Slf(term.name, cont(term.type, defs, weak, dup));\n    case \"New\": return norm(term.expr, defs, weak, dup);\n    case \"Use\": return norm(term.expr, defs, weak, dup);\n    case \"Ann\": return norm(term.expr, defs, weak, dup);\n    case \"Ref\": return dereference(term.eras, term.name);\n  }\n}\n\n// Infers the type of a term\nconst infer = (term, defs, ctx = Ctx(), strat = true, seen = {}) => {\n  switch (term[0]) {\n    case \"Typ\":\n      return Typ();\n    case \"All\":\n      var bind_t = infer(term[1].bind, defs, ctx, false, seen);\n      var ex_ctx = extend(ctx, [term[1].name, shift(term[1].bind, 1, 0)]);\n      var body_t = infer(term[1].body, defs, ex_ctx, false, seen);\n      if (!equals(bind_t, Typ(), defs, ctx) || !equals(body_t, Typ(), defs, ctx)) {\n        throw \"[ERROR]\\nForall not a type: `\" + show(term, ctx) + \"`.\\n\\n[CONTEXT]\\n\" + show_context(ctx);\n      }\n      return Typ();\n    case \"Lam\":\n      if (term[1].bind === null) {\n        throw \"[ERROR]\\nCan't infer non-annotated lambda `\"+show(term,ctx)+\"`.\\n\\n[CONTEXT]\\n\" + show_context(ctx);\n      } else if (strat && uses(term[1].body) > 1) {\n        throw \"Non-linear function: \" + show(term, ctx);\n      } else if (strat && !is_at_level(term[1].body, 0)) {\n        throw \"Lambda-bound variable occurs inside boxes: \" + show(term, ctx);\n      } else {\n        var ex_ctx = extend(ctx, [term[1].name, shift(term[1].bind, 1, 0)]);\n        var body_t = infer(term[1].body, defs, ex_ctx, strat, seen);\n        var term_t = All(term[1].name, term[1].bind, body_t, term[1].eras);\n        infer(term_t, defs, ctx, false, seen);\n        return term_t;\n      }\n    case \"App\":\n      var func_t = norm(infer(term[1].func, defs, ctx, strat, seen), defs, true);\n      if (func_t[0] !== \"All\") {\n        throw \"[ERROR]\\nNon-function application on `\" + show(term, ctx) + \"`.\\n\\n[CONTEXT]\\n\" + show_context(ctx);\n      }\n      if (func_t[1].eras !== term[1].eras) {\n        throw \"[ERROR]\\nErasure doesn't match on application `\" + show(term, ctx) + \"`.\\n\\n[CONTEXT]\\n\" + show_context(ctx);\n      }\n      var argm_v = check(term[1].argm, func_t[1].bind, defs, ctx, strat && !func_t[1].eras, seen, () => \"`\" + show(term, ctx) + \"`'s argument\");\n      return subst(func_t[1].body, argm_v, 0);\n    case \"Box\":\n      var expr_t = norm(infer(term[1].expr, defs, ctx, strat, seen), defs, true);\n      if (!equals(expr_t, Typ(), defs, ctx)) {\n        throw \"[ERROR]\\nBox not a type: `\" + show(term, ctx) + \"`.\\n\\n[CONTEXT]\\n\" + show_context(ctx);\n      }\n      return Typ();\n    case \"Put\":\n      if (term[1].type === null) {\n        throw \"[ERROR]\\nCan't infer non-annotated put `\"+show(term,ctx)+\"`.\\n\\n[CONTEXT]\\n\" + show_context(ctx);\n      } else {\n        var term_t = infer(term[1].expr, defs, ctx, strat, seen);\n        return Box(term_t);\n      }\n    case \"Dup\":\n      var expr_t = norm(infer(term[1].expr, defs, ctx, strat, seen), defs, true);\n      if (expr_t[0] !== \"Box\") {\n        throw \"[ERROR]\\nUnboxed duplication: `\" + show(term, ctx) + \"`.\\n\\n[CONTEXT]\\n\" + show_context(ctx);\n      }\n      if (strat && !is_at_level(term[1].body, 1)) {\n        throw \"[ERROR]\\nOccurrence of duplication varible isn't wrapped by exactly 1 box: `\" + show(term, ctx) + \"`.\\n\\n[CONTEXT]\\n\" + show_context(ctx);\n      }\n      var ex_ctx = extend(ctx, [term[1].name, shift(expr_t[1].expr, 1, 0)]);\n      var body_t = infer(term[1].body, defs, ex_ctx, strat, seen);\n      return subst(body_t, Dup(term[1].name, term[1].expr, Var(0)), 0);\n    case \"Slf\":\n      var ex_ctx = extend(ctx, [term[1].name, shift(term, 1, 0)]);\n      var type_t = infer(term[1].type, defs, ex_ctx, false, seen);\n      if (!equals(type_t, Typ(), defs, ctx)) {\n        throw \"[ERROR]\\nSelf not a type: `\" + show(term, ctx) + \"`.\\n\\n[CONTEXT]\\n\" + show_context(ctx);\n      }\n      return Typ();\n    case \"New\":\n      var type = norm(term[1].type, defs, true);\n      if (type[0] !== \"Slf\") { \n        throw \"[ERROR]\\nNon-self instantiation: `\" + show(term, ctx) + \"`.\\n\\n[CONTEXT]\\n\" + show_context(ctx);\n      }\n      infer(type, defs, ctx, false, seen);\n      check(term[1].expr, subst(type[1].type, Ann(type, term, true), 0), defs, ctx, strat, seen);\n      return term[1].type;\n    case \"Use\":\n      var expr_t = norm(infer(term[1].expr, defs, ctx, false, seen), defs, true);\n      if (expr_t[0] !== \"Slf\") {\n        throw \"[ERROR]\\nNon-self projection: `\" + show(term, ctx) + \"`.\\n\\n[CONTEXT]\\n\" + show_context(ctx);\n      }\n      return subst(expr_t[1].type, term[1].expr, 0);\n    case \"Ann\":\n      if (!term[1].done) {\n        term[1].done = true;\n        check(term[1].expr, term[1].type, defs, ctx, strat, seen);\n      }\n      return term[1].type;\n    case \"Ref\":\n      if (strat && seen[term[1].name]) {\n        throw \"[ERROR]\\nRecursive use of: `\" + term[1].name + \"`.\";\n      }\n      if (!defs[term[1].name]) {\n        throw \"[ERROR]\\nUndefined reference: `\" + term[1].name + \"`.\";\n      }\n      var def = defs[term[1].name];\n      return infer(def, defs, ctx, strat, Object.assign({[term[1].name]: true}, seen));\n    case \"Var\":\n      return get_term(ctx, term[1].index);\n  }\n}\n\n// Checks if a term has given type\nconst check = (term, type, defs, ctx = Ctx(), strat = true, seen = {}, expr = null) => {\n  var expr   = expr || (() => \"`\" + show(term, ctx) + \"`\");\n  var type_n = norm(type, defs, true);\n  if (type_n[0] === \"All\" && term[0] === \"Lam\") {\n    if (type_n[1].eras !== term[1].eras) {\n      throw \"Erasure doesn't match on \" + expr() + \".\";\n    }\n    if (strat && uses(term[1].body) > 1) {\n      throw \"Non-linear function: \" + show(term, ctx);\n    }\n    if (strat && !is_at_level(term[1].body, 0)) {\n      throw \"Lambda-bound variable occurs inside boxes: \" + show(term, ctx);\n    }\n    infer(type_n, defs, ctx, false, seen);\n    var ex_ctx = extend(ctx, [term[1].name, shift(type_n[1].bind, 1, 0)]);\n    var body_v = check(term[1].body, type_n[1].body, defs, ex_ctx, strat, seen, () => \"`\" + show(term, ctx) + \"`'s body\");\n    return Lam(type_n[1].name, type_n[1].bind, body_v, type_n[1].eras);\n  } else if (type_n[0] === \"Box\" && term[0] === \"Put\") {\n    var expr_v = check(term[1].expr, type_n[1].expr, defs, ctx, strat, seen, () => \"`\" + show(term, ctx) + \"`.\");\n    return Put(expr_v);\n  } else if (term[0] === \"Dup\") {\n    var expr_t = norm(infer(term[1].expr, defs, ctx, strat, seen), defs, true);\n    if (expr_t[0] !== \"Box\") {\n      throw \"[ERROR]\\nUnboxed duplication: `\" + show(term, ctx) + \"`.\\n\\n[CONTEXT]\\n\" + show_context(ctx);\n    }\n    if (strat && !is_at_level(term[1].body, 1)) {\n      throw \"[ERROR]\\nOccurrence of duplication varible isn't wrapped by exactly 1 box: `\" + show(term, ctx) + \"`.\\n\\n[CONTEXT]\\n\" + show_context(ctx);\n    }\n    var ex_ctx = extend(ctx, [term[1].name, shift(expr_t[1].expr, 1, 0)]);\n    var body_v = check(term[1].body, shift(type_n, 1, 0), defs, ex_ctx, strat, seen, () => \"`\" + show(term, ctx) + \"`'s body\");\n    return Dup(term[1].name, term[1].expr, body_v);\n  } else {\n    var term_t = infer(term, defs, ctx, strat, seen);\n    try {\n      var checks = equals(type_n, term_t, defs, ctx);\n      var unsure = false;\n    } catch (e) {\n      var checks = false;\n      var unsure = true;\n    }\n    if (!checks) {\n      var error = unsure ? \"Couldn't decide if terms are equal.\" : \"\";\n      var error = error + show_mismatch(type, term_t, expr, ctx, defs);\n      throw error;\n    }\n    return term;\n  }\n}\n\n// Formats a type-mismatch error message\nconst show_mismatch = (expect, actual, expr, ctx, defs) => {\n  var text = \"\";\n  text += \"[ERROR]\\nType mismatch on \" + expr() + \".\\n\";\n  text += \"- Expected:\\n\";\n  text += \"-- type: \" + show(expect, ctx) + \"\\n\";\n  text += \"-- nf-0: \" + show(norm(expect, {}, true), ctx) + \"\\n\";\n  text += \"-- nf-1: \" + show(norm(expect, {}, false), ctx) + \"\\n\";\n  text += \"-- nf-2: \" + show(norm(erase(expect), defs, true), ctx) + \"\\n\";\n  text += \"-- nf-3: \" + show(norm(erase(expect), defs, false), ctx) + \"\\n\";\n  text += \"- Actual:\\n\";\n  text += \"-- type: \" + show(actual, ctx) + \"\\n\";\n  text += \"-- nf-0: \" + show(norm(actual, {}, true), ctx) + \"\\n\";\n  text += \"-- nf-1: \" + show(norm(actual, {}, false), ctx) + \"\\n\";\n  text += \"-- nf-2: \" + show(norm(erase(actual), defs, true), ctx) + \"\\n\";\n  text += \"-- nf-3: \" + show(norm(erase(actual), defs, false), ctx) + \"\\n\";\n  text += \"\\n[CONTEXT]\\n\" \n  text += show_context(ctx);\n  return text;\n}\n\nmodule.exports = {\n  gen_name,\n  Ctx,\n  extend,\n  get_bind,\n  get_name,\n  get_term,\n  index_of,\n  show_context,\n  show_mismatch,\n  Var,\n  Typ,\n  All,\n  Lam,\n  App,\n  Ref,\n  show,\n  parse,\n  norm,\n  infer,\n  check,\n  equals,\n  erase\n};\n\n\n//# sourceURL=webpack:///./node_modules/formality-lang/formality.js?");

/***/ }),

/***/ "./node_modules/formality-lang/index.js":
/*!**********************************************!*\
  !*** ./node_modules/formality-lang/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var compiler = __webpack_require__(/*! ./compiler.js */ \"./node_modules/formality-lang/compiler.js\");\nvar nasic = __webpack_require__(/*! ./nasic.js */ \"./node_modules/formality-lang/nasic.js\");\nvar formality = __webpack_require__(/*! ./formality.js */ \"./node_modules/formality-lang/formality.js\");\n\nvar lib = {};\n\nfor (var key in compiler) {\n  lib[key] = compiler[key];\n}\n\nfor (var key in nasic) {\n  lib[key] = nasic[key];\n}\n\nfor (var key in formality) {\n  lib[key] = formality[key];\n}\n\nmodule.exports = lib;\n\n\n//# sourceURL=webpack:///./node_modules/formality-lang/index.js?");

/***/ }),

/***/ "./node_modules/formality-lang/nasic.js":
/*!**********************************************!*\
  !*** ./node_modules/formality-lang/nasic.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("class Pointer {\n  // A Pointer consists of an addr / port pair\n  constructor(addr, port) {\n    this.addr = addr; // integer (index on this.nodes where the target port is)\n    this.port = port; // integer (0, 1 or 2, representing the target port)\n  }\n\n  to_string() {\n    return this.addr + 'abc'[this.port];\n  }\n  \n  equal(other) {\n    return other !== null && this.addr === other.addr && this.port === other.port;\n  }\n}\n\nclass Node {\n  // A node consists of a label and an array with 3 ports \n  constructor(label, ports) {\n    this.label = label; // integer (this node's label)\n    this.ports = ports; // array with 3 pointers (this node's edges)\n  }\n\n  to_string() {\n    return '[' + this.label + '|' + this.ports[0].to_string() + ' ' + this.ports[1].to_string() + ' ' + this.ports[2].to_string() + ']';\n  }\n}\n \nclass Net {\n  // A net stores nodes (this.nodes), reclaimable memory addrs (this.freed) and active pairs (this.redex)\n  constructor() {\n    this.nodes = []; // nodes\n    this.freed = []; // integers\n    this.redex = []; // array of (integer, integer) tuples representing addrs\n  }\n\n  // Allocates a new node, return its addr\n  alloc_node(label) {\n\n    // If there is reclaimable memory, use it\n    if (this.freed.length > 0) {\n      var addr = this.freed.pop();\n    } else { // Otherwise, extend the array of nodes\n      this.nodes.push(null);\n      var addr = this.nodes.length - 1;\n    }\n\n    // Fill the memory with an empty node without pointers\n    this.nodes[addr] = new Node(label, [null, null, null]);\n    return addr;\n  }\n\n  // Deallocates a node, allowing its space to be reclaimed\n  free_node(addr) {\n    this.nodes[addr] = null;\n    this.freed.push(addr);\n  }\n\n  // Given a pointer to a port, returns a pointer to the opposing port\n  enter_port(ptr) {\n    if (this.nodes[ptr.addr] !== null) {\n      return this.nodes[ptr.addr].ports[ptr.port];\n    } else {\n      return null;\n    }\n  }\n\n  // Connects two ports\n  link_ports(a_ptr, b_ptr) {\n    // Stores each pointer on its opposing port\n    this.nodes[a_ptr.addr].ports[a_ptr.port] = b_ptr;\n    this.nodes[b_ptr.addr].ports[b_ptr.port] = a_ptr;\n\n    // If both are main ports, add this to the list of active pairs\n    if (a_ptr.port === 0 && b_ptr.port === 0) {\n      this.redex.push([a_ptr.addr, b_ptr.addr]);\n    } \n  }\n\n  // Disconnects a port, causing both sides to point to themselves\n  unlink_port(a_ptr) {\n    var b_ptr = this.enter_port(a_ptr);\n    if (this.enter_port(b_ptr).equal(a_ptr)) {\n      this.nodes[a_ptr.addr].ports[a_ptr.port] = a_ptr;\n      this.nodes[b_ptr.addr].ports[b_ptr.port] = b_ptr;\n    }\n  }\n\n  // Rewrites an active pair\n  rewrite([a_addr, b_addr]) {\n    var a_node = this.nodes[a_addr];\n    var b_node = this.nodes[b_addr];\n\n    // If both nodes have the same label, connects their neighbors\n    if (a_node.label === b_node.label) {\n      var a_aux1_dest = this.enter_port(new Pointer(a_addr, 1));\n      var b_aux1_dest = this.enter_port(new Pointer(b_addr, 1));\n      this.link_ports(a_aux1_dest, b_aux1_dest);\n      var a_aux2_dest = this.enter_port(new Pointer(a_addr, 2));\n      var b_aux2_dest = this.enter_port(new Pointer(b_addr, 2));\n      this.link_ports(a_aux2_dest, b_aux2_dest);\n\n    // Otherwise, the nodes pass through each-other, duplicating themselves\n    } else {\n      var p_addr = this.alloc_node(b_node.label);\n      var q_addr = this.alloc_node(b_node.label);\n      var r_addr = this.alloc_node(a_node.label);\n      var s_addr = this.alloc_node(a_node.label);\n      this.link_ports(new Pointer(r_addr, 1), new Pointer(p_addr, 1));\n      this.link_ports(new Pointer(s_addr, 1), new Pointer(p_addr, 2));\n      this.link_ports(new Pointer(r_addr, 2), new Pointer(q_addr, 1));\n      this.link_ports(new Pointer(s_addr, 2), new Pointer(q_addr, 2));\n      this.link_ports(new Pointer(p_addr, 0), this.enter_port(new Pointer(a_addr, 1)));\n      this.link_ports(new Pointer(q_addr, 0), this.enter_port(new Pointer(a_addr, 2)));\n      this.link_ports(new Pointer(r_addr, 0), this.enter_port(new Pointer(b_addr, 1)));\n      this.link_ports(new Pointer(s_addr, 0), this.enter_port(new Pointer(b_addr, 2)));\n    }\n\n    // Deallocates the space used by the active pair\n    for (var i = 0; i < 3; i++) {\n      this.unlink_port(new Pointer(a_addr, i));\n      this.unlink_port(new Pointer(b_addr, i));\n    }\n    this.free_node(a_addr);\n    if (a_addr !== b_addr) {\n      this.free_node(b_addr);\n    }\n  }\n\n  // Rewrites active pairs until none is left, reducing the graph to normal form\n  // This could be performed in parallel. Unreachable data is freed automatically.\n  reduce() {\n    var rewrite_count = 0;\n    while (this.redex.length > 0) {\n      this.rewrite(this.redex.pop());\n      rewrite_count += 1;\n    }\n    return {rewrites: rewrite_count};\n  }\n\n  // Rewrites active pairs lazily. Lazy reductions avoid wasting work and\n  // allows recursive terms, but requires GC and enforces sequentiality.\n  reduce_lazy() {\n    var warp = [];\n    var exit = [];\n    var next = this.enter_port(new Pointer(0, 1));\n    var prev = null;\n    var back = null;\n    var rwts = 0;\n    while (next.addr > 0 || warp.length > 0) {\n      next = next.addr === 0 ? this.enter_port(warp.pop()) : next;\n      prev = this.enter_port(next);\n      if (next.port === 0 && prev.port === 0) {\n        back = this.enter_port(new Pointer(prev.addr, exit.pop()));\n        this.rewrite([prev.addr, next.addr]);\n        next = this.enter_port(back);\n        ++rwts;\n      } else if (next.port === 0) {\n        warp.push(new Pointer(next.addr, 2));\n        next = this.enter_port(new Pointer(next.addr, 1));\n      } else {\n        exit.push(next.port);\n        next = this.enter_port(new Pointer(next.addr, 0));\n      }\n    }\n    return {rewrites: rwts};\n  }\n\n  to_string() {\n    var text = '';\n    for (var i = 0; i < this.nodes.length; i++) {\n      if (this.nodes[i] !== null) {\n        text += i + ': ' + this.nodes[i].to_string() + '\\n';\n      } else {\n        text += i + ': ' + null + '\\n';\n      }\n    }\n    return text;\n  }\n}\n\nmodule.exports = {Pointer, Node, Net};\n\n\n//# sourceURL=webpack:///./node_modules/formality-lang/nasic.js?");

/***/ }),

/***/ "./node_modules/inferno-canvas-component-2/inferno-canvas-component.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/inferno-canvas-component-2/inferno-canvas-component.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {Component} = __webpack_require__(/*! inferno */ \"./node_modules/inferno/index.esm.js\");\nconst h = __webpack_require__(/*! inferno-hyperscript */ \"./node_modules/inferno-hyperscript/dist/index.esm.js\").h;\n\nmodule.exports = class InfernoCanvasComponent extends Component {\n    getChildContext() {\n        const {context, props, canvasElement} = this;\n        const ctx = canvasElement && canvasElement.getContext('2d');\n        const realtime = (context && context.realtime) || props.realtime;\n        return {ctx, realtime};\n    }\n\n    constructor(props) {\n        super(props);\n        this.refDOM = this.refDOM.bind(this);\n        this.requestAnimationFrameCallback = this.requestAnimationFrameCallback.bind(this);\n    }\n\n    componentDidMount() {\n        this.forceUpdate();\n        requestAnimationFrame(this.requestAnimationFrameCallback);\n    }\n\n    render() {\n        const {props, context} = this;\n        const {draw, realtime, top, left, ...other} = props;\n        requestAnimationFrame(this.requestAnimationFrameCallback)\n        return h(\"canvas\", {ref: this.refDOM, key: \"canvas\", ...other}, props.children);\n    }\n\n    refDOM(element) {\n        this.canvasElement = element;\n    }\n\n    requestAnimationFrameCallback(time) {\n        if (this.previousFrameTime !== time) {\n            const {props, context, canvasElement} = this;\n            const {draw, top, left} = props;\n            const ctx = canvasElement && canvasElement.getContext('2d');\n            const realtime = (context && context.realtime) || props.realtime;\n            let delta = 0;\n            if (realtime) {\n                requestAnimationFrame(this.requestAnimationFrameCallback);\n                if (this.previousFrameTime) {\n                    delta = time - this.previousFrameTime;\n                }\n                else {\n                    this.previousFrameTime = time;\n                }\n                this.previousFrameTime = time;\n            }\n            draw({time, delta, ctx});\n        }\n    }\n};\n\n//# sourceURL=webpack:///./node_modules/inferno-canvas-component-2/inferno-canvas-component.js?");

/***/ }),

/***/ "./node_modules/inferno-hyperscript/dist/index.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/inferno-hyperscript/dist/index.esm.js ***!
  \************************************************************/
/*! exports provided: h */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return h; });\n/* harmony import */ var inferno__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inferno */ \"./node_modules/inferno/index.esm.js\");\n\n\nvar isArray = Array.isArray;\nfunction isStringOrNumber(o) {\n    var type = typeof o;\n    return type === 'string' || type === 'number';\n}\nfunction isString(o) {\n    return typeof o === 'string';\n}\nfunction isUndefined(o) {\n    return o === void 0;\n}\n\nvar classIdSplit = /([.#]?[a-zA-Z0-9_:-]+)/;\nvar notClassId = /^\\.|#/;\nfunction parseTag(tag, props) {\n    if (!tag) {\n        return 'div';\n    }\n    if (tag === inferno__WEBPACK_IMPORTED_MODULE_0__[\"Fragment\"]) {\n        return tag;\n    }\n    var noId = props && isUndefined(props.id);\n    var tagParts = tag.split(classIdSplit);\n    var tagName = null;\n    if (notClassId.test(tagParts[1])) {\n        tagName = 'div';\n    }\n    var classes;\n    for (var i = 0, len = tagParts.length; i < len; ++i) {\n        var part = tagParts[i];\n        if (!part) {\n            continue;\n        }\n        var type = part.charAt(0);\n        if (!tagName) {\n            tagName = part;\n        }\n        else if (type === '.') {\n            if (classes === void 0) {\n                classes = [];\n            }\n            classes.push(part.substring(1, part.length));\n        }\n        else if (type === '#' && noId) {\n            props.id = part.substring(1, part.length);\n        }\n    }\n    if (classes) {\n        if (props.className) {\n            classes.push(props.className);\n        }\n        props.className = classes.join(' ');\n    }\n    return tagName || 'div';\n}\nfunction isChildren(x) {\n    return isStringOrNumber(x) || (x && isArray(x));\n}\n/**\n * Creates virtual node\n * @param {string|VNode|Function} _tag Name for virtual node\n * @param {object=} _props Additional properties for virtual node\n * @param {string|number|VNode|Array<string|number|VNode>|null=} _children Optional children for virtual node\n * @returns {VNode} returns new virtual node\n */\nfunction h(_tag, _props, _children) {\n    // If a child array or text node are passed as the second argument, shift them\n    if (!_children && isChildren(_props)) {\n        _children = _props;\n        _props = {};\n    }\n    var isElement = isString(_tag);\n    _props = _props || {};\n    var tag = isElement ? parseTag(_tag, _props) : _tag;\n    var newProps = {};\n    var key = null;\n    var ref = null;\n    var children = null;\n    var className = null;\n    for (var prop in _props) {\n        if (isElement && (prop === 'className' || prop === 'class')) {\n            className = _props[prop];\n        }\n        else if (prop === 'key') {\n            key = _props[prop];\n        }\n        else if (prop === 'ref') {\n            ref = _props[prop];\n        }\n        else if (prop === 'hooks') {\n            ref = _props[prop];\n        }\n        else if (prop === 'children') {\n            children = _props[prop];\n        }\n        else if (!isElement && prop.substr(0, 11) === 'onComponent') {\n            if (!ref) {\n                ref = {};\n            }\n            ref[prop] = _props[prop];\n        }\n        else {\n            newProps[prop] = _props[prop];\n        }\n    }\n    if (isElement) {\n        var flags = Object(inferno__WEBPACK_IMPORTED_MODULE_0__[\"getFlagsForElementVnode\"])(tag);\n        if (flags & 8192 /* Fragment */) {\n            return Object(inferno__WEBPACK_IMPORTED_MODULE_0__[\"createFragment\"])(_children || children, 0 /* UnknownChildren */, key);\n        }\n        if (newProps.contenteditable !== void 0) {\n            flags |= 4096 /* ContentEditable */;\n        }\n        return Object(inferno__WEBPACK_IMPORTED_MODULE_0__[\"createVNode\"])(flags, tag, className, _children || children, 0 /* UnknownChildren */, newProps, key, ref);\n    }\n    if (children || _children) {\n        newProps.children = children || _children;\n    }\n    return Object(inferno__WEBPACK_IMPORTED_MODULE_0__[\"createComponentVNode\"])(2 /* ComponentUnknown */, tag, newProps, key, ref);\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/inferno-hyperscript/dist/index.esm.js?");

/***/ }),

/***/ "./node_modules/inferno/dist/index.esm.js":
/*!************************************************!*\
  !*** ./node_modules/inferno/dist/index.esm.js ***!
  \************************************************/
/*! exports provided: Component, Fragment, EMPTY_OBJ, createComponentVNode, createFragment, createPortal, createRef, createRenderer, createTextVNode, createVNode, forwardRef, directClone, findDOMfromVNode, getFlagsForElementVnode, linkEvent, normalizeProps, options, render, rerender, version, _CI, _HI, _M, _MCCC, _ME, _MFCC, _MR, _MT, _MP, __render */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return Component; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Fragment\", function() { return Fragment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EMPTY_OBJ\", function() { return EMPTY_OBJ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createComponentVNode\", function() { return createComponentVNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createFragment\", function() { return createFragment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createPortal\", function() { return createPortal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createRef\", function() { return createRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createRenderer\", function() { return createRenderer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createTextVNode\", function() { return createTextVNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createVNode\", function() { return createVNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forwardRef\", function() { return forwardRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"directClone\", function() { return directClone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findDOMfromVNode\", function() { return findDOMfromVNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getFlagsForElementVnode\", function() { return getFlagsForElementVnode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"linkEvent\", function() { return linkEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalizeProps\", function() { return normalizeProps; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"options\", function() { return options; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rerender\", function() { return rerender; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"version\", function() { return version; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_CI\", function() { return createClassComponentInstance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_HI\", function() { return handleComponentInput; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_M\", function() { return mount; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MCCC\", function() { return mountClassComponentCallbacks; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_ME\", function() { return mountElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MFCC\", function() { return mountFunctionalComponentCallbacks; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MR\", function() { return mountRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MT\", function() { return mountText; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MP\", function() { return mountProps; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__render\", function() { return __render; });\nvar isArray = Array.isArray;\nfunction isStringOrNumber(o) {\n    var type = typeof o;\n    return type === 'string' || type === 'number';\n}\nfunction isNullOrUndef(o) {\n    return isUndefined(o) || isNull(o);\n}\nfunction isInvalid(o) {\n    return isNull(o) || o === false || isTrue(o) || isUndefined(o);\n}\nfunction isFunction(o) {\n    return typeof o === 'function';\n}\nfunction isString(o) {\n    return typeof o === 'string';\n}\nfunction isNumber(o) {\n    return typeof o === 'number';\n}\nfunction isNull(o) {\n    return o === null;\n}\nfunction isTrue(o) {\n    return o === true;\n}\nfunction isUndefined(o) {\n    return o === void 0;\n}\nfunction isObject(o) {\n    return typeof o === 'object';\n}\nfunction combineFrom(first, second) {\n    var out = {};\n    if (first) {\n        for (var key in first) {\n            out[key] = first[key];\n        }\n    }\n    if (second) {\n        for (var key$1 in second) {\n            out[key$1] = second[key$1];\n        }\n    }\n    return out;\n}\n\n// We need EMPTY_OBJ defined in one place.\n// Its used for comparison so we cant inline it into shared\nvar EMPTY_OBJ = {};\nvar Fragment = '$F';\nfunction normalizeEventName(name) {\n    return name.substr(2).toLowerCase();\n}\nfunction appendChild(parentDOM, dom) {\n    parentDOM.appendChild(dom);\n}\nfunction insertOrAppend(parentDOM, newNode, nextNode) {\n    if (isNull(nextNode)) {\n        appendChild(parentDOM, newNode);\n    }\n    else {\n        parentDOM.insertBefore(newNode, nextNode);\n    }\n}\nfunction documentCreateElement(tag, isSVG) {\n    if (isSVG) {\n        return document.createElementNS('http://www.w3.org/2000/svg', tag);\n    }\n    return document.createElement(tag);\n}\nfunction replaceChild(parentDOM, newDom, lastDom) {\n    parentDOM.replaceChild(newDom, lastDom);\n}\nfunction removeChild(parentDOM, childNode) {\n    parentDOM.removeChild(childNode);\n}\nfunction callAll(arrayFn) {\n    var listener;\n    while ((listener = arrayFn.shift()) !== undefined) {\n        listener();\n    }\n}\nfunction findDOMfromVNode(vNode, start) {\n    var flags;\n    var children;\n    while (vNode) {\n        flags = vNode.flags;\n        if (flags & 2033 /* DOMRef */) {\n            return vNode.dom;\n        }\n        children = vNode.children;\n        if (flags & 8192 /* Fragment */) {\n            vNode = vNode.childFlags === 2 /* HasVNodeChildren */ ? children : children[start ? 0 : children.length - 1];\n        }\n        else if (flags & 4 /* ComponentClass */) {\n            vNode = children.$LI;\n        }\n        else {\n            vNode = children;\n        }\n    }\n    return null;\n}\nfunction removeVNodeDOM(vNode, parentDOM) {\n    var flags = vNode.flags;\n    if (flags & 2033 /* DOMRef */) {\n        removeChild(parentDOM, vNode.dom);\n    }\n    else {\n        var children = vNode.children;\n        if (flags & 4 /* ComponentClass */) {\n            removeVNodeDOM(children.$LI, parentDOM);\n        }\n        else if (flags & 8 /* ComponentFunction */) {\n            removeVNodeDOM(children, parentDOM);\n        }\n        else if (flags & 8192 /* Fragment */) {\n            if (vNode.childFlags === 2 /* HasVNodeChildren */) {\n                removeVNodeDOM(children, parentDOM);\n            }\n            else {\n                for (var i = 0, len = children.length; i < len; ++i) {\n                    removeVNodeDOM(children[i], parentDOM);\n                }\n            }\n        }\n    }\n}\nfunction moveVNodeDOM(vNode, parentDOM, nextNode) {\n    var flags = vNode.flags;\n    if (flags & 2033 /* DOMRef */) {\n        insertOrAppend(parentDOM, vNode.dom, nextNode);\n    }\n    else {\n        var children = vNode.children;\n        if (flags & 4 /* ComponentClass */) {\n            moveVNodeDOM(children.$LI, parentDOM, nextNode);\n        }\n        else if (flags & 8 /* ComponentFunction */) {\n            moveVNodeDOM(children, parentDOM, nextNode);\n        }\n        else if (flags & 8192 /* Fragment */) {\n            if (vNode.childFlags === 2 /* HasVNodeChildren */) {\n                moveVNodeDOM(children, parentDOM, nextNode);\n            }\n            else {\n                for (var i = 0, len = children.length; i < len; ++i) {\n                    moveVNodeDOM(children[i], parentDOM, nextNode);\n                }\n            }\n        }\n    }\n}\nfunction createDerivedState(instance, nextProps, state) {\n    if (instance.constructor.getDerivedStateFromProps) {\n        return combineFrom(state, instance.constructor.getDerivedStateFromProps(nextProps, state));\n    }\n    return state;\n}\nvar renderCheck = {\n    v: false\n};\nvar options = {\n    componentComparator: null,\n    createVNode: null,\n    renderComplete: null\n};\nfunction setTextContent(dom, children) {\n    dom.textContent = children;\n}\nfunction isSameLinkEvent(lastValue, nextValue) {\n    return (lastValue &&\n        nextValue &&\n        isObject(lastValue) &&\n        isObject(nextValue) &&\n        lastValue.event === nextValue.event &&\n        lastValue.data === nextValue.data);\n}\n\nvar keyPrefix = '$';\nfunction V(childFlags, children, className, flags, key, props, ref, type) {\n    this.childFlags = childFlags;\n    this.children = children;\n    this.className = className;\n    this.dom = null;\n    this.flags = flags;\n    this.key = key === void 0 ? null : key;\n    this.props = props === void 0 ? null : props;\n    this.ref = ref === void 0 ? null : ref;\n    this.type = type;\n}\nfunction createVNode(flags, type, className, children, childFlags, props, key, ref) {\n    var childFlag = childFlags === void 0 ? 1 /* HasInvalidChildren */ : childFlags;\n    var vNode = new V(childFlag, children, className, flags, key, props, ref, type);\n    var optsVNode = options.createVNode;\n    if (isFunction(optsVNode)) {\n        optsVNode(vNode);\n    }\n    if (childFlag === 0 /* UnknownChildren */) {\n        normalizeChildren(vNode, vNode.children);\n    }\n    return vNode;\n}\nfunction createComponentVNode(flags, type, props, key, ref) {\n    if ((flags & 2 /* ComponentUnknown */) !== 0) {\n        if (type.prototype && type.prototype.render) {\n            flags = 4 /* ComponentClass */;\n        }\n        else if (type.render) {\n            flags = 32776 /* ForwardRefComponent */;\n            type = type.render;\n        }\n        else {\n            flags = 8 /* ComponentFunction */;\n        }\n    }\n    // set default props\n    var defaultProps = type.defaultProps;\n    if (!isNullOrUndef(defaultProps)) {\n        if (!props) {\n            props = {}; // Props can be referenced and modified at application level so always create new object\n        }\n        for (var prop in defaultProps) {\n            if (isUndefined(props[prop])) {\n                props[prop] = defaultProps[prop];\n            }\n        }\n    }\n    if ((flags & 8 /* ComponentFunction */) > 0 && (flags & 32768 /* ForwardRef */) === 0) {\n        var defaultHooks = type.defaultHooks;\n        if (!isNullOrUndef(defaultHooks)) {\n            if (!ref) {\n                // As ref cannot be referenced from application level, we can use the same refs object\n                ref = defaultHooks;\n            }\n            else {\n                for (var prop$1 in defaultHooks) {\n                    if (isUndefined(ref[prop$1])) {\n                        ref[prop$1] = defaultHooks[prop$1];\n                    }\n                }\n            }\n        }\n    }\n    var vNode = new V(1 /* HasInvalidChildren */, null, null, flags, key, props, ref, type);\n    var optsVNode = options.createVNode;\n    if (isFunction(optsVNode)) {\n        optsVNode(vNode);\n    }\n    return vNode;\n}\nfunction createTextVNode(text, key) {\n    return new V(1 /* HasInvalidChildren */, isNullOrUndef(text) ? '' : text, null, 16 /* Text */, key, null, null, null);\n}\nfunction createFragment(children, childFlags, key) {\n    var fragment = createVNode(8192 /* Fragment */, 8192 /* Fragment */, null, children, childFlags, null, key, null);\n    switch (fragment.childFlags) {\n        case 1 /* HasInvalidChildren */:\n            fragment.children = createVoidVNode();\n            fragment.childFlags = 2 /* HasVNodeChildren */;\n            break;\n        case 16 /* HasTextChildren */:\n            fragment.children = [createTextVNode(children)];\n            fragment.childFlags = 4 /* HasNonKeyedChildren */;\n            break;\n        default:\n            break;\n    }\n    return fragment;\n}\nfunction normalizeProps(vNode) {\n    var props = vNode.props;\n    if (props) {\n        var flags = vNode.flags;\n        if (flags & 481 /* Element */) {\n            if (props.children !== void 0 && isNullOrUndef(vNode.children)) {\n                normalizeChildren(vNode, props.children);\n            }\n            if (props.className !== void 0) {\n                vNode.className = props.className || null;\n                props.className = undefined;\n            }\n        }\n        if (props.key !== void 0) {\n            vNode.key = props.key;\n            props.key = undefined;\n        }\n        if (props.ref !== void 0) {\n            if (flags & 8 /* ComponentFunction */) {\n                vNode.ref = combineFrom(vNode.ref, props.ref);\n            }\n            else {\n                vNode.ref = props.ref;\n            }\n            props.ref = undefined;\n        }\n    }\n    return vNode;\n}\n/*\n * Fragment is different than normal vNode,\n * because when it needs to be cloned we need to clone its children too\n * But not normalize, because otherwise those possibly get KEY and re-mount\n */\nfunction cloneFragment(vNodeToClone) {\n    var clonedChildren;\n    var oldChildren = vNodeToClone.children;\n    var childFlags = vNodeToClone.childFlags;\n    if (childFlags === 2 /* HasVNodeChildren */) {\n        clonedChildren = directClone(oldChildren);\n    }\n    else if (childFlags & 12 /* MultipleChildren */) {\n        clonedChildren = [];\n        for (var i = 0, len = oldChildren.length; i < len; ++i) {\n            clonedChildren.push(directClone(oldChildren[i]));\n        }\n    }\n    return createFragment(clonedChildren, childFlags, vNodeToClone.key);\n}\nfunction directClone(vNodeToClone) {\n    var flags = vNodeToClone.flags & -16385 /* ClearInUse */;\n    var props = vNodeToClone.props;\n    if (flags & 14 /* Component */) {\n        if (!isNull(props)) {\n            var propsToClone = props;\n            props = {};\n            for (var key in propsToClone) {\n                props[key] = propsToClone[key];\n            }\n        }\n    }\n    if ((flags & 8192 /* Fragment */) === 0) {\n        return new V(vNodeToClone.childFlags, vNodeToClone.children, vNodeToClone.className, flags, vNodeToClone.key, props, vNodeToClone.ref, vNodeToClone.type);\n    }\n    return cloneFragment(vNodeToClone);\n}\nfunction createVoidVNode() {\n    return createTextVNode('', null);\n}\nfunction createPortal(children, container) {\n    return createVNode(1024 /* Portal */, 1024 /* Portal */, null, children, 0 /* UnknownChildren */, null, isInvalid(children) ? null : children.key, container);\n}\nfunction _normalizeVNodes(nodes, result, index, currentKey) {\n    for (var len = nodes.length; index < len; index++) {\n        var n = nodes[index];\n        if (!isInvalid(n)) {\n            var newKey = currentKey + keyPrefix + index;\n            if (isArray(n)) {\n                _normalizeVNodes(n, result, 0, newKey);\n            }\n            else {\n                if (isStringOrNumber(n)) {\n                    n = createTextVNode(n, newKey);\n                }\n                else {\n                    var oldKey = n.key;\n                    var isPrefixedKey = isString(oldKey) && oldKey[0] === keyPrefix;\n                    if (n.flags & 81920 /* InUseOrNormalized */ || isPrefixedKey) {\n                        n = directClone(n);\n                    }\n                    n.flags |= 65536 /* Normalized */;\n                    if (!isPrefixedKey) {\n                        if (isNull(oldKey)) {\n                            n.key = newKey;\n                        }\n                        else {\n                            n.key = currentKey + oldKey;\n                        }\n                    }\n                    else if (oldKey.substring(0, currentKey.length) !== currentKey) {\n                        n.key = currentKey + oldKey;\n                    }\n                }\n                result.push(n);\n            }\n        }\n    }\n}\nfunction getFlagsForElementVnode(type) {\n    switch (type) {\n        case 'svg':\n            return 32 /* SvgElement */;\n        case 'input':\n            return 64 /* InputElement */;\n        case 'select':\n            return 256 /* SelectElement */;\n        case 'textarea':\n            return 128 /* TextareaElement */;\n        case Fragment:\n            return 8192 /* Fragment */;\n        default:\n            return 1 /* HtmlElement */;\n    }\n}\nfunction normalizeChildren(vNode, children) {\n    var newChildren;\n    var newChildFlags = 1 /* HasInvalidChildren */;\n    // Don't change children to match strict equal (===) true in patching\n    if (isInvalid(children)) {\n        newChildren = children;\n    }\n    else if (isStringOrNumber(children)) {\n        newChildFlags = 16 /* HasTextChildren */;\n        newChildren = children;\n    }\n    else if (isArray(children)) {\n        var len = children.length;\n        for (var i = 0; i < len; ++i) {\n            var n = children[i];\n            if (isInvalid(n) || isArray(n)) {\n                newChildren = newChildren || children.slice(0, i);\n                _normalizeVNodes(children, newChildren, i, '');\n                break;\n            }\n            else if (isStringOrNumber(n)) {\n                newChildren = newChildren || children.slice(0, i);\n                newChildren.push(createTextVNode(n, keyPrefix + i));\n            }\n            else {\n                var key = n.key;\n                var needsCloning = (n.flags & 81920 /* InUseOrNormalized */) > 0;\n                var isNullKey = isNull(key);\n                var isPrefixed = isString(key) && key[0] === keyPrefix;\n                if (needsCloning || isNullKey || isPrefixed) {\n                    newChildren = newChildren || children.slice(0, i);\n                    if (needsCloning || isPrefixed) {\n                        n = directClone(n);\n                    }\n                    if (isNullKey || isPrefixed) {\n                        n.key = keyPrefix + i;\n                    }\n                    newChildren.push(n);\n                }\n                else if (newChildren) {\n                    newChildren.push(n);\n                }\n                n.flags |= 65536 /* Normalized */;\n            }\n        }\n        newChildren = newChildren || children;\n        if (newChildren.length === 0) {\n            newChildFlags = 1 /* HasInvalidChildren */;\n        }\n        else {\n            newChildFlags = 8 /* HasKeyedChildren */;\n        }\n    }\n    else {\n        newChildren = children;\n        newChildren.flags |= 65536 /* Normalized */;\n        if (children.flags & 81920 /* InUseOrNormalized */) {\n            newChildren = directClone(children);\n        }\n        newChildFlags = 2 /* HasVNodeChildren */;\n    }\n    vNode.children = newChildren;\n    vNode.childFlags = newChildFlags;\n    return vNode;\n}\n\n/**\n * Links given data to event as first parameter\n * @param {*} data data to be linked, it will be available in function as first parameter\n * @param {Function} event Function to be called when event occurs\n * @returns {{data: *, event: Function}}\n */\nfunction linkEvent(data, event) {\n    if (isFunction(event)) {\n        return { data: data, event: event };\n    }\n    return null; // Return null when event is invalid, to avoid creating unnecessary event handlers\n}\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\nvar xmlNS = 'http://www.w3.org/XML/1998/namespace';\nvar namespaces = {\n    'xlink:actuate': xlinkNS,\n    'xlink:arcrole': xlinkNS,\n    'xlink:href': xlinkNS,\n    'xlink:role': xlinkNS,\n    'xlink:show': xlinkNS,\n    'xlink:title': xlinkNS,\n    'xlink:type': xlinkNS,\n    'xml:base': xmlNS,\n    'xml:lang': xmlNS,\n    'xml:space': xmlNS\n};\n\nfunction getDelegatedEventObject(v) {\n    return {\n        onClick: v,\n        onDblClick: v,\n        onFocusIn: v,\n        onFocusOut: v,\n        onKeyDown: v,\n        onKeyPress: v,\n        onKeyUp: v,\n        onMouseDown: v,\n        onMouseMove: v,\n        onMouseUp: v,\n        onSubmit: v,\n        onTouchEnd: v,\n        onTouchMove: v,\n        onTouchStart: v\n    };\n}\nvar attachedEventCounts = getDelegatedEventObject(0);\nvar attachedEvents = getDelegatedEventObject(null);\nvar delegatedEvents = getDelegatedEventObject(true);\nfunction handleEvent(name, nextEvent, dom) {\n    var eventsObject = dom.$EV;\n    if (nextEvent) {\n        if (attachedEventCounts[name] === 0) {\n            attachedEvents[name] = attachEventToDocument(name);\n        }\n        if (!eventsObject) {\n            eventsObject = dom.$EV = getDelegatedEventObject(null);\n        }\n        if (!eventsObject[name]) {\n            ++attachedEventCounts[name];\n        }\n        eventsObject[name] = nextEvent;\n    }\n    else if (eventsObject && eventsObject[name]) {\n        if (--attachedEventCounts[name] === 0) {\n            document.removeEventListener(normalizeEventName(name), attachedEvents[name]);\n            attachedEvents[name] = null;\n        }\n        eventsObject[name] = null;\n    }\n}\nfunction dispatchEvents(event, target, isClick, name, eventData) {\n    var dom = target;\n    while (!isNull(dom)) {\n        // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,\n        // because the event listener is on document.body\n        // Don't process clicks on disabled elements\n        if (isClick && dom.disabled) {\n            return;\n        }\n        var eventsObject = dom.$EV;\n        if (eventsObject) {\n            var currentEvent = eventsObject[name];\n            if (currentEvent) {\n                // linkEvent object\n                eventData.dom = dom;\n                if (currentEvent.event) {\n                    currentEvent.event(currentEvent.data, event);\n                }\n                else {\n                    currentEvent(event);\n                }\n                if (event.cancelBubble) {\n                    return;\n                }\n            }\n        }\n        dom = dom.parentNode;\n    }\n}\nfunction stopPropagation() {\n    this.cancelBubble = true;\n    if (!this.immediatePropagationStopped) {\n        this.stopImmediatePropagation();\n    }\n}\nfunction isDefaultPrevented() {\n    return this.defaultPrevented;\n}\nfunction isPropagationStopped() {\n    return this.cancelBubble;\n}\nfunction attachEventToDocument(name) {\n    var docEvent = function (event) {\n        var isClick = name === 'onClick' || name === 'onDblClick';\n        if (isClick && event.button !== 0) {\n            // Firefox incorrectly triggers click event for mid/right mouse buttons.\n            // This bug has been active for 12 years.\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=184051\n            event.stopPropagation();\n            return;\n        }\n        event.isDefaultPrevented = isDefaultPrevented;\n        event.isPropagationStopped = isPropagationStopped;\n        event.stopPropagation = stopPropagation;\n        // Event data needs to be object to save reference to currentTarget getter\n        var eventData = {\n            dom: document\n        };\n        Object.defineProperty(event, 'currentTarget', {\n            configurable: true,\n            get: function get() {\n                return eventData.dom;\n            }\n        });\n        dispatchEvents(event, event.target, isClick, name, eventData);\n    };\n    document.addEventListener(normalizeEventName(name), docEvent);\n    return docEvent;\n}\n\nfunction isSameInnerHTML(dom, innerHTML) {\n    var tempdom = document.createElement('i');\n    tempdom.innerHTML = innerHTML;\n    return tempdom.innerHTML === dom.innerHTML;\n}\n\nfunction triggerEventListener(props, methodName, e) {\n    if (props[methodName]) {\n        var listener = props[methodName];\n        if (listener.event) {\n            listener.event(listener.data, e);\n        }\n        else {\n            listener(e);\n        }\n    }\n    else {\n        var nativeListenerName = methodName.toLowerCase();\n        if (props[nativeListenerName]) {\n            props[nativeListenerName](e);\n        }\n    }\n}\nfunction createWrappedFunction(methodName, applyValue) {\n    var fnMethod = function (e) {\n        var vNode = this.$V;\n        // If vNode is gone by the time event fires, no-op\n        if (!vNode) {\n            return;\n        }\n        var props = vNode.props || EMPTY_OBJ;\n        var dom = vNode.dom;\n        if (isString(methodName)) {\n            triggerEventListener(props, methodName, e);\n        }\n        else {\n            for (var i = 0; i < methodName.length; ++i) {\n                triggerEventListener(props, methodName[i], e);\n            }\n        }\n        if (isFunction(applyValue)) {\n            var newVNode = this.$V;\n            var newProps = newVNode.props || EMPTY_OBJ;\n            applyValue(newProps, dom, false, newVNode);\n        }\n    };\n    Object.defineProperty(fnMethod, 'wrapped', {\n        configurable: false,\n        enumerable: false,\n        value: true,\n        writable: false\n    });\n    return fnMethod;\n}\n\nfunction attachEvent(dom, event, handler) {\n    var previousKey = \"$\" + event;\n    var previousArgs = dom[previousKey];\n    if (previousArgs && previousArgs[1].wrapped) {\n        return;\n    }\n    if (previousArgs) {\n        dom.removeEventListener.apply(dom, previousArgs);\n        dom[previousKey] = null;\n    }\n    if (isFunction(handler)) {\n        dom.addEventListener(event, handler);\n        dom[previousKey] = [event, handler];\n    }\n}\n\nfunction isCheckedType(type) {\n    return type === 'checkbox' || type === 'radio';\n}\nvar onTextInputChange = createWrappedFunction('onInput', applyValueInput);\nvar wrappedOnChange = createWrappedFunction(['onClick', 'onChange'], applyValueInput);\n/* tslint:disable-next-line:no-empty */\nfunction emptywrapper(event) {\n    event.stopPropagation();\n}\nemptywrapper.wrapped = true;\nfunction inputEvents(dom, nextPropsOrEmpty) {\n    if (isCheckedType(nextPropsOrEmpty.type)) {\n        attachEvent(dom, 'change', wrappedOnChange);\n        attachEvent(dom, 'click', emptywrapper);\n    }\n    else {\n        attachEvent(dom, 'input', onTextInputChange);\n    }\n}\nfunction applyValueInput(nextPropsOrEmpty, dom) {\n    var type = nextPropsOrEmpty.type;\n    var value = nextPropsOrEmpty.value;\n    var checked = nextPropsOrEmpty.checked;\n    var multiple = nextPropsOrEmpty.multiple;\n    var defaultValue = nextPropsOrEmpty.defaultValue;\n    var hasValue = !isNullOrUndef(value);\n    if (type && type !== dom.type) {\n        dom.setAttribute('type', type);\n    }\n    if (!isNullOrUndef(multiple) && multiple !== dom.multiple) {\n        dom.multiple = multiple;\n    }\n    if (!isNullOrUndef(defaultValue) && !hasValue) {\n        dom.defaultValue = defaultValue + '';\n    }\n    if (isCheckedType(type)) {\n        if (hasValue) {\n            dom.value = value;\n        }\n        if (!isNullOrUndef(checked)) {\n            dom.checked = checked;\n        }\n    }\n    else {\n        if (hasValue && dom.value !== value) {\n            dom.defaultValue = value;\n            dom.value = value;\n        }\n        else if (!isNullOrUndef(checked)) {\n            dom.checked = checked;\n        }\n    }\n}\n\nfunction updateChildOptions(vNode, value) {\n    if (vNode.type === 'option') {\n        updateChildOption(vNode, value);\n    }\n    else {\n        var children = vNode.children;\n        var flags = vNode.flags;\n        if (flags & 4 /* ComponentClass */) {\n            updateChildOptions(children.$LI, value);\n        }\n        else if (flags & 8 /* ComponentFunction */) {\n            updateChildOptions(children, value);\n        }\n        else if (vNode.childFlags === 2 /* HasVNodeChildren */) {\n            updateChildOptions(children, value);\n        }\n        else if (vNode.childFlags & 12 /* MultipleChildren */) {\n            for (var i = 0, len = children.length; i < len; ++i) {\n                updateChildOptions(children[i], value);\n            }\n        }\n    }\n}\nfunction updateChildOption(vNode, value) {\n    var props = vNode.props || EMPTY_OBJ;\n    var dom = vNode.dom;\n    // we do this as multiple may have changed\n    dom.value = props.value;\n    if (props.value === value || (isArray(value) && value.indexOf(props.value) !== -1)) {\n        dom.selected = true;\n    }\n    else if (!isNullOrUndef(value) || !isNullOrUndef(props.selected)) {\n        dom.selected = props.selected || false;\n    }\n}\nvar onSelectChange = createWrappedFunction('onChange', applyValueSelect);\nfunction selectEvents(dom) {\n    attachEvent(dom, 'change', onSelectChange);\n}\nfunction applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode) {\n    var multiplePropInBoolean = Boolean(nextPropsOrEmpty.multiple);\n    if (!isNullOrUndef(nextPropsOrEmpty.multiple) && multiplePropInBoolean !== dom.multiple) {\n        dom.multiple = multiplePropInBoolean;\n    }\n    var index = nextPropsOrEmpty.selectedIndex;\n    if (index === -1) {\n        dom.selectedIndex = -1;\n    }\n    var childFlags = vNode.childFlags;\n    if (childFlags !== 1 /* HasInvalidChildren */) {\n        var value = nextPropsOrEmpty.value;\n        if (isNumber(index) && index > -1 && dom.options[index]) {\n            value = dom.options[index].value;\n        }\n        if (mounting && isNullOrUndef(value)) {\n            value = nextPropsOrEmpty.defaultValue;\n        }\n        updateChildOptions(vNode, value);\n    }\n}\n\nvar onTextareaInputChange = createWrappedFunction('onInput', applyValueTextArea);\nvar wrappedOnChange$1 = createWrappedFunction('onChange');\nfunction textAreaEvents(dom, nextPropsOrEmpty) {\n    attachEvent(dom, 'input', onTextareaInputChange);\n    if (nextPropsOrEmpty.onChange) {\n        attachEvent(dom, 'change', wrappedOnChange$1);\n    }\n}\nfunction applyValueTextArea(nextPropsOrEmpty, dom, mounting) {\n    var value = nextPropsOrEmpty.value;\n    var domValue = dom.value;\n    if (isNullOrUndef(value)) {\n        if (mounting) {\n            var defaultValue = nextPropsOrEmpty.defaultValue;\n            if (!isNullOrUndef(defaultValue) && defaultValue !== domValue) {\n                dom.defaultValue = defaultValue;\n                dom.value = defaultValue;\n            }\n        }\n    }\n    else if (domValue !== value) {\n        /* There is value so keep it controlled */\n        dom.defaultValue = value;\n        dom.value = value;\n    }\n}\n\n/**\n * There is currently no support for switching same input between controlled and nonControlled\n * If that ever becomes a real issue, then re design controlled elements\n * Currently user must choose either controlled or non-controlled and stick with that\n */\nfunction processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\n    if (flags & 64 /* InputElement */) {\n        applyValueInput(nextPropsOrEmpty, dom);\n    }\n    else if (flags & 256 /* SelectElement */) {\n        applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode);\n    }\n    else if (flags & 128 /* TextareaElement */) {\n        applyValueTextArea(nextPropsOrEmpty, dom, mounting);\n    }\n    if (isControlled) {\n        dom.$V = vNode;\n    }\n}\nfunction addFormElementEventHandlers(flags, dom, nextPropsOrEmpty) {\n    if (flags & 64 /* InputElement */) {\n        inputEvents(dom, nextPropsOrEmpty);\n    }\n    else if (flags & 256 /* SelectElement */) {\n        selectEvents(dom);\n    }\n    else if (flags & 128 /* TextareaElement */) {\n        textAreaEvents(dom, nextPropsOrEmpty);\n    }\n}\nfunction isControlledFormElement(nextPropsOrEmpty) {\n    return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);\n}\n\nfunction createRef() {\n    return {\n        current: null\n    };\n}\nvar forwardRef = function (render) {\n        return {\n            render: render\n        };\n    };\nfunction pushRef(dom, value, lifecycle) {\n    lifecycle.push(function () {\n        value(dom);\n    });\n}\nfunction unmountRef(ref) {\n    if (ref) {\n        if (isFunction(ref)) {\n            ref(null);\n        }\n        else if (ref.current) {\n            ref.current = null;\n        }\n    }\n}\nfunction mountRef(ref, value, lifecycle) {\n    if (ref) {\n        if (isFunction(ref)) {\n            pushRef(value, ref, lifecycle);\n        }\n        else if (ref.current !== void 0) {\n            ref.current = value;\n        }\n    }\n}\n\nfunction remove(vNode, parentDOM) {\n    unmount(vNode);\n    if (parentDOM) {\n        removeVNodeDOM(vNode, parentDOM);\n    }\n}\nfunction unmount(vNode) {\n    var flags = vNode.flags;\n    var children = vNode.children;\n    var ref;\n    if (flags & 481 /* Element */) {\n        ref = vNode.ref;\n        var props = vNode.props;\n        unmountRef(ref);\n        var childFlags = vNode.childFlags;\n        if (!isNull(props)) {\n            var keys = Object.keys(props);\n            for (var i = 0, len = keys.length; i < len; i++) {\n                var key = keys[i];\n                if (delegatedEvents[key]) {\n                    handleEvent(key, null, vNode.dom);\n                }\n            }\n        }\n        if (childFlags & 12 /* MultipleChildren */) {\n            unmountAllChildren(children);\n        }\n        else if (childFlags === 2 /* HasVNodeChildren */) {\n            unmount(children);\n        }\n    }\n    else if (children) {\n        if (flags & 4 /* ComponentClass */) {\n            if (isFunction(children.componentWillUnmount)) {\n                children.componentWillUnmount();\n            }\n            unmountRef(vNode.ref);\n            children.$UN = true;\n            unmount(children.$LI);\n        }\n        else if (flags & 8 /* ComponentFunction */) {\n            ref = vNode.ref;\n            if (!isNullOrUndef(ref) && isFunction(ref.onComponentWillUnmount)) {\n                ref.onComponentWillUnmount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);\n            }\n            unmount(children);\n        }\n        else if (flags & 1024 /* Portal */) {\n            remove(children, vNode.ref);\n        }\n        else if (flags & 8192 /* Fragment */) {\n            if (vNode.childFlags & 12 /* MultipleChildren */) {\n                unmountAllChildren(children);\n            }\n        }\n    }\n}\nfunction unmountAllChildren(children) {\n    for (var i = 0, len = children.length; i < len; ++i) {\n        unmount(children[i]);\n    }\n}\nfunction clearDOM(dom) {\n    // Optimization for clearing dom\n    dom.textContent = '';\n}\nfunction removeAllChildren(dom, vNode, children) {\n    unmountAllChildren(children);\n    if (vNode.flags & 8192 /* Fragment */) {\n        removeVNodeDOM(vNode, dom);\n    }\n    else {\n        clearDOM(dom);\n    }\n}\n\nfunction createLinkEvent(linkEvent, nextValue) {\n    return function (e) {\n        linkEvent(nextValue.data, e);\n    };\n}\nfunction patchEvent(name, lastValue, nextValue, dom) {\n    var event = normalizeEventName(name);\n    if (isObject(nextValue) && !isNull(nextValue)) {\n        var linkEvent = nextValue.event;\n        if (!isSameLinkEvent(lastValue, nextValue)) {\n            attachEvent(dom, event, createLinkEvent(linkEvent, nextValue));\n        }\n    }\n    else {\n        attachEvent(dom, event, nextValue);\n    }\n}\n// We are assuming here that we come from patchProp routine\n// -nextAttrValue cannot be null or undefined\nfunction patchStyle(lastAttrValue, nextAttrValue, dom) {\n    if (isNullOrUndef(nextAttrValue)) {\n        dom.removeAttribute('style');\n        return;\n    }\n    var domStyle = dom.style;\n    var style;\n    var value;\n    if (isString(nextAttrValue)) {\n        domStyle.cssText = nextAttrValue;\n        return;\n    }\n    if (!isNullOrUndef(lastAttrValue) && !isString(lastAttrValue)) {\n        for (style in nextAttrValue) {\n            // do not add a hasOwnProperty check here, it affects performance\n            value = nextAttrValue[style];\n            if (value !== lastAttrValue[style]) {\n                domStyle.setProperty(style, value);\n            }\n        }\n        for (style in lastAttrValue) {\n            if (isNullOrUndef(nextAttrValue[style])) {\n                domStyle.removeProperty(style);\n            }\n        }\n    }\n    else {\n        for (style in nextAttrValue) {\n            value = nextAttrValue[style];\n            domStyle.setProperty(style, value);\n        }\n    }\n}\nfunction patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode) {\n    switch (prop) {\n        case 'children':\n        case 'childrenType':\n        case 'className':\n        case 'defaultValue':\n        case 'key':\n        case 'multiple':\n        case 'ref':\n            break;\n        case 'autoFocus':\n            dom.autofocus = !!nextValue;\n            break;\n        case 'allowfullscreen':\n        case 'autoplay':\n        case 'capture':\n        case 'checked':\n        case 'controls':\n        case 'default':\n        case 'disabled':\n        case 'hidden':\n        case 'indeterminate':\n        case 'loop':\n        case 'muted':\n        case 'novalidate':\n        case 'open':\n        case 'readOnly':\n        case 'required':\n        case 'reversed':\n        case 'scoped':\n        case 'seamless':\n        case 'selected':\n            dom[prop] = !!nextValue;\n            break;\n        case 'defaultChecked':\n        case 'value':\n        case 'volume':\n            if (hasControlledValue && prop === 'value') {\n                break;\n            }\n            var value = isNullOrUndef(nextValue) ? '' : nextValue;\n            if (dom[prop] !== value) {\n                dom[prop] = value;\n            }\n            break;\n        case 'style':\n            patchStyle(lastValue, nextValue, dom);\n            break;\n        case 'dangerouslySetInnerHTML':\n            var lastHtml = (lastValue && lastValue.__html) || '';\n            var nextHtml = (nextValue && nextValue.__html) || '';\n            if (lastHtml !== nextHtml) {\n                if (!isNullOrUndef(nextHtml) && !isSameInnerHTML(dom, nextHtml)) {\n                    if (!isNull(lastVNode)) {\n                        if (lastVNode.childFlags & 12 /* MultipleChildren */) {\n                            unmountAllChildren(lastVNode.children);\n                        }\n                        else if (lastVNode.childFlags === 2 /* HasVNodeChildren */) {\n                            unmount(lastVNode.children);\n                        }\n                        lastVNode.children = null;\n                        lastVNode.childFlags = 1 /* HasInvalidChildren */;\n                    }\n                    dom.innerHTML = nextHtml;\n                }\n            }\n            break;\n        default:\n            if (delegatedEvents[prop]) {\n                if (!isSameLinkEvent(lastValue, nextValue)) {\n                    handleEvent(prop, nextValue, dom);\n                }\n            }\n            else if (prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110) {\n                patchEvent(prop, lastValue, nextValue, dom);\n            }\n            else if (isNullOrUndef(nextValue)) {\n                dom.removeAttribute(prop);\n            }\n            else if (isSVG && namespaces[prop]) {\n                // We optimize for isSVG being false\n                // If we end up in this path we can read property again\n                dom.setAttributeNS(namespaces[prop], prop, nextValue);\n            }\n            else {\n                dom.setAttribute(prop, nextValue);\n            }\n            break;\n    }\n}\nfunction mountProps(vNode, flags, props, dom, isSVG) {\n    var hasControlledValue = false;\n    var isFormElement = (flags & 448 /* FormElement */) > 0;\n    if (isFormElement) {\n        hasControlledValue = isControlledFormElement(props);\n        if (hasControlledValue) {\n            addFormElementEventHandlers(flags, dom, props);\n        }\n    }\n    for (var prop in props) {\n        // do not add a hasOwnProperty check here, it affects performance\n        patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue, null);\n    }\n    if (isFormElement) {\n        processElement(flags, vNode, dom, props, true, hasControlledValue);\n    }\n}\n\nfunction renderNewInput(instance, props, context) {\n    var nextInput = handleComponentInput(instance.render(props, instance.state, context));\n    var childContext = context;\n    if (isFunction(instance.getChildContext)) {\n        childContext = combineFrom(context, instance.getChildContext());\n    }\n    instance.$CX = childContext;\n    return nextInput;\n}\nfunction createClassComponentInstance(vNode, Component, props, context, isSVG, lifecycle) {\n    var instance = new Component(props, context);\n    var usesNewAPI = (instance.$N = Boolean(Component.getDerivedStateFromProps || instance.getSnapshotBeforeUpdate));\n    instance.$SVG = isSVG;\n    instance.$L = lifecycle;\n    vNode.children = instance;\n    instance.$BS = false;\n    instance.context = context;\n    if (instance.props === EMPTY_OBJ) {\n        instance.props = props;\n    }\n    if (!usesNewAPI) {\n        if (isFunction(instance.componentWillMount)) {\n            instance.$BR = true;\n            instance.componentWillMount();\n            var pending = instance.$PS;\n            if (!isNull(pending)) {\n                var state = instance.state;\n                if (isNull(state)) {\n                    instance.state = pending;\n                }\n                else {\n                    for (var key in pending) {\n                        state[key] = pending[key];\n                    }\n                }\n                instance.$PS = null;\n            }\n            instance.$BR = false;\n        }\n    }\n    else {\n        instance.state = createDerivedState(instance, props, instance.state);\n    }\n    instance.$LI = renderNewInput(instance, props, context);\n    return instance;\n}\nfunction handleComponentInput(input) {\n    if (isInvalid(input)) {\n        input = createVoidVNode();\n    }\n    else if (isStringOrNumber(input)) {\n        input = createTextVNode(input, null);\n    }\n    else if (isArray(input)) {\n        input = createFragment(input, 0 /* UnknownChildren */, null);\n    }\n    else if (input.flags & 16384 /* InUse */) {\n        input = directClone(input);\n    }\n    return input;\n}\n\nfunction mount(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var flags = (vNode.flags |= 16384 /* InUse */);\n    if (flags & 481 /* Element */) {\n        mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (flags & 4 /* ComponentClass */) {\n        mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (flags & 8 /* ComponentFunction */) {\n        mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (flags & 512 /* Void */ || flags & 16 /* Text */) {\n        mountText(vNode, parentDOM, nextNode);\n    }\n    else if (flags & 8192 /* Fragment */) {\n        mountFragment(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (flags & 1024 /* Portal */) {\n        mountPortal(vNode, context, parentDOM, nextNode, lifecycle);\n    }\n}\nfunction mountPortal(vNode, context, parentDOM, nextNode, lifecycle) {\n    mount(vNode.children, vNode.ref, context, false, null, lifecycle);\n    var placeHolderVNode = createVoidVNode();\n    mountText(placeHolderVNode, parentDOM, nextNode);\n    vNode.dom = placeHolderVNode.dom;\n}\nfunction mountFragment(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var children = vNode.children;\n    var childFlags = vNode.childFlags;\n    // When fragment is optimized for multiple children, check if there is no children and change flag to invalid\n    // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements\n    if (childFlags & 12 /* MultipleChildren */ && children.length === 0) {\n        childFlags = vNode.childFlags = 2 /* HasVNodeChildren */;\n        children = vNode.children = createVoidVNode();\n    }\n    if (childFlags === 2 /* HasVNodeChildren */) {\n        mount(children, parentDOM, nextNode, isSVG, nextNode, lifecycle);\n    }\n    else {\n        mountArrayChildren(children, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n}\nfunction mountText(vNode, parentDOM, nextNode) {\n    var dom = (vNode.dom = document.createTextNode(vNode.children));\n    if (!isNull(parentDOM)) {\n        insertOrAppend(parentDOM, dom, nextNode);\n    }\n}\nfunction mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var flags = vNode.flags;\n    var props = vNode.props;\n    var className = vNode.className;\n    var ref = vNode.ref;\n    var children = vNode.children;\n    var childFlags = vNode.childFlags;\n    isSVG = isSVG || (flags & 32 /* SvgElement */) > 0;\n    var dom = documentCreateElement(vNode.type, isSVG);\n    vNode.dom = dom;\n    if (!isNullOrUndef(className) && className !== '') {\n        if (isSVG) {\n            dom.setAttribute('class', className);\n        }\n        else {\n            dom.className = className;\n        }\n    }\n    if (childFlags === 16 /* HasTextChildren */) {\n        setTextContent(dom, children);\n    }\n    else if (childFlags !== 1 /* HasInvalidChildren */) {\n        var childrenIsSVG = isSVG && vNode.type !== 'foreignObject';\n        if (childFlags === 2 /* HasVNodeChildren */) {\n            if (children.flags & 16384 /* InUse */) {\n                vNode.children = children = directClone(children);\n            }\n            mount(children, dom, context, childrenIsSVG, null, lifecycle);\n        }\n        else if (childFlags === 8 /* HasKeyedChildren */ || childFlags === 4 /* HasNonKeyedChildren */) {\n            mountArrayChildren(children, dom, context, childrenIsSVG, null, lifecycle);\n        }\n    }\n    if (!isNull(parentDOM)) {\n        insertOrAppend(parentDOM, dom, nextNode);\n    }\n    if (!isNull(props)) {\n        mountProps(vNode, flags, props, dom, isSVG);\n    }\n    mountRef(ref, dom, lifecycle);\n}\nfunction mountArrayChildren(children, dom, context, isSVG, nextNode, lifecycle) {\n    for (var i = 0, len = children.length; i < len; ++i) {\n        var child = children[i];\n        if (child.flags & 16384 /* InUse */) {\n            children[i] = child = directClone(child);\n        }\n        mount(child, dom, context, isSVG, nextNode, lifecycle);\n    }\n}\nfunction mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var instance = createClassComponentInstance(vNode, vNode.type, vNode.props || EMPTY_OBJ, context, isSVG, lifecycle);\n    mount(instance.$LI, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);\n    mountClassComponentCallbacks(vNode.ref, instance, lifecycle);\n}\nfunction mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var type = vNode.type;\n    var props = vNode.props || EMPTY_OBJ;\n    var ref = vNode.ref;\n    var input = handleComponentInput(vNode.flags & 32768 /* ForwardRef */ ? type(props, ref, context) : type(props, context));\n    vNode.children = input;\n    mount(input, parentDOM, context, isSVG, nextNode, lifecycle);\n    mountFunctionalComponentCallbacks(props, ref, vNode, lifecycle);\n}\nfunction createClassMountCallback(instance) {\n    return function () {\n        instance.componentDidMount();\n    };\n}\nfunction mountClassComponentCallbacks(ref, instance, lifecycle) {\n    mountRef(ref, instance, lifecycle);\n    if (isFunction(instance.componentDidMount)) {\n        lifecycle.push(createClassMountCallback(instance));\n    }\n}\nfunction createOnMountCallback(ref, vNode, props) {\n    return function () {\n        ref.onComponentDidMount(findDOMfromVNode(vNode, true), props);\n    };\n}\nfunction mountFunctionalComponentCallbacks(props, ref, vNode, lifecycle) {\n    if (!isNullOrUndef(ref)) {\n        if (isFunction(ref.onComponentWillMount)) {\n            ref.onComponentWillMount(props);\n        }\n        if (isFunction(ref.onComponentDidMount)) {\n            lifecycle.push(createOnMountCallback(ref, vNode, props));\n        }\n    }\n}\n\nfunction replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {\n    unmount(lastVNode);\n    if ((nextVNode.flags & lastVNode.flags & 2033 /* DOMRef */) !== 0) {\n        // Single DOM operation, when we have dom references available\n        mount(nextVNode, null, context, isSVG, null, lifecycle);\n        // Single DOM operation, when we have dom references available\n        replaceChild(parentDOM, nextVNode.dom, lastVNode.dom);\n    }\n    else {\n        mount(nextVNode, parentDOM, context, isSVG, findDOMfromVNode(lastVNode, true), lifecycle);\n        removeVNodeDOM(lastVNode, parentDOM);\n    }\n}\nfunction patch(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var nextFlags = (nextVNode.flags |= 16384 /* InUse */);\n    if (lastVNode.flags !== nextFlags || lastVNode.type !== nextVNode.type || lastVNode.key !== nextVNode.key || (nextFlags & 2048 /* ReCreate */) !== 0) {\n        if (lastVNode.flags & 16384 /* InUse */) {\n            replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);\n        }\n        else {\n            // Last vNode is not in use, it has crashed at application level. Just mount nextVNode and ignore last one\n            mount(nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n        }\n    }\n    else if (nextFlags & 481 /* Element */) {\n        patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle);\n    }\n    else if (nextFlags & 4 /* ComponentClass */) {\n        patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (nextFlags & 8 /* ComponentFunction */) {\n        patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (nextFlags & 16 /* Text */) {\n        patchText(lastVNode, nextVNode);\n    }\n    else if (nextFlags & 512 /* Void */) {\n        nextVNode.dom = lastVNode.dom;\n    }\n    else if (nextFlags & 8192 /* Fragment */) {\n        patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);\n    }\n    else {\n        patchPortal(lastVNode, nextVNode, context, lifecycle);\n    }\n}\nfunction patchSingleTextChild(lastChildren, nextChildren, parentDOM) {\n    if (lastChildren !== nextChildren) {\n        if (lastChildren !== '') {\n            parentDOM.firstChild.nodeValue = nextChildren;\n        }\n        else {\n            setTextContent(parentDOM, nextChildren);\n        }\n    }\n}\nfunction patchContentEditableChildren(dom, nextChildren) {\n    if (dom.textContent !== nextChildren) {\n        dom.textContent = nextChildren;\n    }\n}\nfunction patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {\n    var lastChildren = lastVNode.children;\n    var nextChildren = nextVNode.children;\n    var lastChildFlags = lastVNode.childFlags;\n    var nextChildFlags = nextVNode.childFlags;\n    var nextNode = null;\n    // When fragment is optimized for multiple children, check if there is no children and change flag to invalid\n    // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements\n    if (nextChildFlags & 12 /* MultipleChildren */ && nextChildren.length === 0) {\n        nextChildFlags = nextVNode.childFlags = 2 /* HasVNodeChildren */;\n        nextChildren = nextVNode.children = createVoidVNode();\n    }\n    var nextIsSingle = (nextChildFlags & 2 /* HasVNodeChildren */) !== 0;\n    if (lastChildFlags & 12 /* MultipleChildren */) {\n        var lastLen = lastChildren.length;\n        // We need to know Fragment's edge node when\n        if (\n        // It uses keyed algorithm\n        (lastChildFlags & 8 /* HasKeyedChildren */ && nextChildFlags & 8 /* HasKeyedChildren */) ||\n            // It transforms from many to single\n            nextIsSingle ||\n            // It will append more nodes\n            (!nextIsSingle && nextChildren.length > lastLen)) {\n            // When fragment has multiple children there is always at least one vNode\n            nextNode = findDOMfromVNode(lastChildren[lastLen - 1], false).nextSibling;\n        }\n    }\n    patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lastVNode, lifecycle);\n}\nfunction patchPortal(lastVNode, nextVNode, context, lifecycle) {\n    var lastContainer = lastVNode.ref;\n    var nextContainer = nextVNode.ref;\n    var nextChildren = nextVNode.children;\n    patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, lastContainer, context, false, null, lastVNode, lifecycle);\n    nextVNode.dom = lastVNode.dom;\n    if (lastContainer !== nextContainer && !isInvalid(nextChildren)) {\n        var node = nextChildren.dom;\n        removeChild(lastContainer, node);\n        appendChild(nextContainer, node);\n    }\n}\nfunction patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle) {\n    var dom = lastVNode.dom;\n    var lastProps = lastVNode.props;\n    var nextProps = nextVNode.props;\n    var isFormElement = false;\n    var hasControlledValue = false;\n    var nextPropsOrEmpty;\n    nextVNode.dom = dom;\n    isSVG = isSVG || (nextFlags & 32 /* SvgElement */) > 0;\n    // inlined patchProps  -- starts --\n    if (lastProps !== nextProps) {\n        var lastPropsOrEmpty = lastProps || EMPTY_OBJ;\n        nextPropsOrEmpty = nextProps || EMPTY_OBJ;\n        if (nextPropsOrEmpty !== EMPTY_OBJ) {\n            isFormElement = (nextFlags & 448 /* FormElement */) > 0;\n            if (isFormElement) {\n                hasControlledValue = isControlledFormElement(nextPropsOrEmpty);\n            }\n            for (var prop in nextPropsOrEmpty) {\n                var lastValue = lastPropsOrEmpty[prop];\n                var nextValue = nextPropsOrEmpty[prop];\n                if (lastValue !== nextValue) {\n                    patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode);\n                }\n            }\n        }\n        if (lastPropsOrEmpty !== EMPTY_OBJ) {\n            for (var prop$1 in lastPropsOrEmpty) {\n                if (isNullOrUndef(nextPropsOrEmpty[prop$1]) && !isNullOrUndef(lastPropsOrEmpty[prop$1])) {\n                    patchProp(prop$1, lastPropsOrEmpty[prop$1], null, dom, isSVG, hasControlledValue, lastVNode);\n                }\n            }\n        }\n    }\n    var nextChildren = nextVNode.children;\n    var nextClassName = nextVNode.className;\n    // inlined patchProps  -- ends --\n    if (lastVNode.className !== nextClassName) {\n        if (isNullOrUndef(nextClassName)) {\n            dom.removeAttribute('class');\n        }\n        else if (isSVG) {\n            dom.setAttribute('class', nextClassName);\n        }\n        else {\n            dom.className = nextClassName;\n        }\n    }\n    if (nextFlags & 4096 /* ContentEditable */) {\n        patchContentEditableChildren(dom, nextChildren);\n    }\n    else {\n        patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, dom, context, isSVG && nextVNode.type !== 'foreignObject', null, lastVNode, lifecycle);\n    }\n    if (isFormElement) {\n        processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, false, hasControlledValue);\n    }\n    var nextRef = nextVNode.ref;\n    var lastRef = lastVNode.ref;\n    if (lastRef !== nextRef) {\n        unmountRef(lastRef);\n        mountRef(nextRef, dom, lifecycle);\n    }\n}\nfunction replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle) {\n    unmount(lastChildren);\n    mountArrayChildren(nextChildren, parentDOM, context, isSVG, findDOMfromVNode(lastChildren, true), lifecycle);\n    removeVNodeDOM(lastChildren, parentDOM);\n}\nfunction patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, parentVNode, lifecycle) {\n    switch (lastChildFlags) {\n        case 2 /* HasVNodeChildren */:\n            switch (nextChildFlags) {\n                case 2 /* HasVNodeChildren */:\n                    patch(lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    remove(lastChildren, parentDOM);\n                    break;\n                case 16 /* HasTextChildren */:\n                    unmount(lastChildren);\n                    setTextContent(parentDOM, nextChildren);\n                    break;\n                default:\n                    replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle);\n                    break;\n            }\n            break;\n        case 1 /* HasInvalidChildren */:\n            switch (nextChildFlags) {\n                case 2 /* HasVNodeChildren */:\n                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    break;\n                case 16 /* HasTextChildren */:\n                    setTextContent(parentDOM, nextChildren);\n                    break;\n                default:\n                    mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n            }\n            break;\n        case 16 /* HasTextChildren */:\n            switch (nextChildFlags) {\n                case 16 /* HasTextChildren */:\n                    patchSingleTextChild(lastChildren, nextChildren, parentDOM);\n                    break;\n                case 2 /* HasVNodeChildren */:\n                    clearDOM(parentDOM);\n                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    clearDOM(parentDOM);\n                    break;\n                default:\n                    clearDOM(parentDOM);\n                    mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n            }\n            break;\n        default:\n            switch (nextChildFlags) {\n                case 16 /* HasTextChildren */:\n                    unmountAllChildren(lastChildren);\n                    setTextContent(parentDOM, nextChildren);\n                    break;\n                case 2 /* HasVNodeChildren */:\n                    removeAllChildren(parentDOM, parentVNode, lastChildren);\n                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    removeAllChildren(parentDOM, parentVNode, lastChildren);\n                    break;\n                default:\n                    var lastLength = lastChildren.length | 0;\n                    var nextLength = nextChildren.length | 0;\n                    // Fast path's for both algorithms\n                    if (lastLength === 0) {\n                        if (nextLength > 0) {\n                            mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                        }\n                    }\n                    else if (nextLength === 0) {\n                        removeAllChildren(parentDOM, parentVNode, lastChildren);\n                    }\n                    else if (nextChildFlags === 8 /* HasKeyedChildren */ && lastChildFlags === 8 /* HasKeyedChildren */) {\n                        patchKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, parentVNode, lifecycle);\n                    }\n                    else {\n                        patchNonKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, lifecycle);\n                    }\n                    break;\n            }\n            break;\n    }\n}\nfunction createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle) {\n    lifecycle.push(function () {\n        instance.componentDidUpdate(lastProps, lastState, snapshot);\n    });\n}\nfunction updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, force, nextNode, lifecycle) {\n    var lastState = instance.state;\n    var lastProps = instance.props;\n    var usesNewAPI = Boolean(instance.$N);\n    var hasSCU = isFunction(instance.shouldComponentUpdate);\n    if (usesNewAPI) {\n        nextState = createDerivedState(instance, nextProps, nextState !== lastState ? combineFrom(lastState, nextState) : nextState);\n    }\n    if (force || !hasSCU || (hasSCU && instance.shouldComponentUpdate(nextProps, nextState, context))) {\n        if (!usesNewAPI && isFunction(instance.componentWillUpdate)) {\n            instance.componentWillUpdate(nextProps, nextState, context);\n        }\n        instance.props = nextProps;\n        instance.state = nextState;\n        instance.context = context;\n        var snapshot = null;\n        var nextInput = renderNewInput(instance, nextProps, context);\n        if (usesNewAPI && isFunction(instance.getSnapshotBeforeUpdate)) {\n            snapshot = instance.getSnapshotBeforeUpdate(lastProps, lastState);\n        }\n        patch(instance.$LI, nextInput, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);\n        // Dont update Last input, until patch has been succesfully executed\n        instance.$LI = nextInput;\n        if (isFunction(instance.componentDidUpdate)) {\n            createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle);\n        }\n    }\n    else {\n        instance.props = nextProps;\n        instance.state = nextState;\n        instance.context = context;\n    }\n}\nfunction patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var instance = (nextVNode.children = lastVNode.children);\n    // If Component has crashed, ignore it to stay functional\n    if (isNull(instance)) {\n        return;\n    }\n    instance.$L = lifecycle;\n    var nextProps = nextVNode.props || EMPTY_OBJ;\n    var nextRef = nextVNode.ref;\n    var lastRef = lastVNode.ref;\n    var nextState = instance.state;\n    if (!instance.$N) {\n        if (isFunction(instance.componentWillReceiveProps)) {\n            instance.$BR = true;\n            instance.componentWillReceiveProps(nextProps, context);\n            // If instance component was removed during its own update do nothing.\n            if (instance.$UN) {\n                return;\n            }\n            instance.$BR = false;\n        }\n        if (!isNull(instance.$PS)) {\n            nextState = combineFrom(nextState, instance.$PS);\n            instance.$PS = null;\n        }\n    }\n    updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, false, nextNode, lifecycle);\n    if (lastRef !== nextRef) {\n        unmountRef(lastRef);\n        mountRef(nextRef, instance, lifecycle);\n    }\n}\nfunction patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var shouldUpdate = true;\n    var nextProps = nextVNode.props || EMPTY_OBJ;\n    var nextRef = nextVNode.ref;\n    var lastProps = lastVNode.props;\n    var nextHooksDefined = !isNullOrUndef(nextRef);\n    var lastInput = lastVNode.children;\n    if (nextHooksDefined && isFunction(nextRef.onComponentShouldUpdate)) {\n        shouldUpdate = nextRef.onComponentShouldUpdate(lastProps, nextProps);\n    }\n    if (shouldUpdate !== false) {\n        if (nextHooksDefined && isFunction(nextRef.onComponentWillUpdate)) {\n            nextRef.onComponentWillUpdate(lastProps, nextProps);\n        }\n        var type = nextVNode.type;\n        var nextInput = handleComponentInput(nextVNode.flags & 32768 /* ForwardRef */ ? type(nextProps, nextRef, context) : type(nextProps, context));\n        patch(lastInput, nextInput, parentDOM, context, isSVG, nextNode, lifecycle);\n        nextVNode.children = nextInput;\n        if (nextHooksDefined && isFunction(nextRef.onComponentDidUpdate)) {\n            nextRef.onComponentDidUpdate(lastProps, nextProps);\n        }\n    }\n    else {\n        nextVNode.children = lastInput;\n    }\n}\nfunction patchText(lastVNode, nextVNode) {\n    var nextText = nextVNode.children;\n    var dom = lastVNode.dom;\n    if (nextText !== lastVNode.children) {\n        dom.nodeValue = nextText;\n    }\n    nextVNode.dom = dom;\n}\nfunction patchNonKeyedChildren(lastChildren, nextChildren, dom, context, isSVG, lastChildrenLength, nextChildrenLength, nextNode, lifecycle) {\n    var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;\n    var i = 0;\n    var nextChild;\n    var lastChild;\n    for (; i < commonLength; ++i) {\n        nextChild = nextChildren[i];\n        lastChild = lastChildren[i];\n        if (nextChild.flags & 16384 /* InUse */) {\n            nextChild = nextChildren[i] = directClone(nextChild);\n        }\n        patch(lastChild, nextChild, dom, context, isSVG, nextNode, lifecycle);\n        lastChildren[i] = nextChild;\n    }\n    if (lastChildrenLength < nextChildrenLength) {\n        for (i = commonLength; i < nextChildrenLength; ++i) {\n            nextChild = nextChildren[i];\n            if (nextChild.flags & 16384 /* InUse */) {\n                nextChild = nextChildren[i] = directClone(nextChild);\n            }\n            mount(nextChild, dom, context, isSVG, nextNode, lifecycle);\n        }\n    }\n    else if (lastChildrenLength > nextChildrenLength) {\n        for (i = commonLength; i < lastChildrenLength; ++i) {\n            remove(lastChildren[i], dom);\n        }\n    }\n}\nfunction patchKeyedChildren(a, b, dom, context, isSVG, aLength, bLength, outerEdge, parentVNode, lifecycle) {\n    var aEnd = aLength - 1;\n    var bEnd = bLength - 1;\n    var i = 0;\n    var j = 0;\n    var aNode = a[j];\n    var bNode = b[j];\n    var nextPos;\n    var nextNode;\n    // Step 1\n    // tslint:disable-next-line\n    outer: {\n        // Sync nodes with the same key at the beginning.\n        while (aNode.key === bNode.key) {\n            if (bNode.flags & 16384 /* InUse */) {\n                b[j] = bNode = directClone(bNode);\n            }\n            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n            a[j] = bNode;\n            ++j;\n            if (j > aEnd || j > bEnd) {\n                break outer;\n            }\n            aNode = a[j];\n            bNode = b[j];\n        }\n        aNode = a[aEnd];\n        bNode = b[bEnd];\n        // Sync nodes with the same key at the end.\n        while (aNode.key === bNode.key) {\n            if (bNode.flags & 16384 /* InUse */) {\n                b[bEnd] = bNode = directClone(bNode);\n            }\n            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n            a[aEnd] = bNode;\n            aEnd--;\n            bEnd--;\n            if (j > aEnd || j > bEnd) {\n                break outer;\n            }\n            aNode = a[aEnd];\n            bNode = b[bEnd];\n        }\n    }\n    if (j > aEnd) {\n        if (j <= bEnd) {\n            nextPos = bEnd + 1;\n            nextNode = nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge;\n            while (j <= bEnd) {\n                bNode = b[j];\n                if (bNode.flags & 16384 /* InUse */) {\n                    b[j] = bNode = directClone(bNode);\n                }\n                ++j;\n                mount(bNode, dom, context, isSVG, nextNode, lifecycle);\n            }\n        }\n    }\n    else if (j > bEnd) {\n        while (j <= aEnd) {\n            remove(a[j++], dom);\n        }\n    }\n    else {\n        var aStart = j;\n        var bStart = j;\n        var aLeft = aEnd - j + 1;\n        var bLeft = bEnd - j + 1;\n        var sources = new Int32Array(bLeft - i + 1);\n        i = bLeft + 2;\n        // Keep track if its possible to remove whole DOM using textContent = '';\n        var canRemoveWholeContent = aLeft === aLength;\n        var moved = false;\n        var pos = 0;\n        var patched = 0;\n        // When sizes are small, just loop them through\n        if (bLength < 4 || (aLeft | bLeft) < 32) {\n            for (i = aStart; i <= aEnd; ++i) {\n                aNode = a[i];\n                if (patched < bLeft) {\n                    for (j = bStart; j <= bEnd; j++) {\n                        bNode = b[j];\n                        if (aNode.key === bNode.key) {\n                            sources[j - bStart] = i + 1;\n                            if (canRemoveWholeContent) {\n                                canRemoveWholeContent = false;\n                                while (aStart < i) {\n                                    remove(a[aStart++], dom);\n                                }\n                            }\n                            if (pos > j) {\n                                moved = true;\n                            }\n                            else {\n                                pos = j;\n                            }\n                            if (bNode.flags & 16384 /* InUse */) {\n                                b[j] = bNode = directClone(bNode);\n                            }\n                            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n                            ++patched;\n                            break;\n                        }\n                    }\n                    if (!canRemoveWholeContent && j > bEnd) {\n                        remove(aNode, dom);\n                    }\n                }\n                else if (!canRemoveWholeContent) {\n                    remove(aNode, dom);\n                }\n            }\n        }\n        else {\n            var keyIndex = {};\n            // Map keys by their index\n            for (i = bStart; i <= bEnd; ++i) {\n                keyIndex[b[i].key] = i;\n            }\n            // Try to patch same keys\n            for (i = aStart; i <= aEnd; ++i) {\n                aNode = a[i];\n                if (patched < bLeft) {\n                    j = keyIndex[aNode.key];\n                    if (j !== void 0) {\n                        if (canRemoveWholeContent) {\n                            canRemoveWholeContent = false;\n                            while (i > aStart) {\n                                remove(a[aStart++], dom);\n                            }\n                        }\n                        bNode = b[j];\n                        sources[j - bStart] = i + 1;\n                        if (pos > j) {\n                            moved = true;\n                        }\n                        else {\n                            pos = j;\n                        }\n                        if (bNode.flags & 16384 /* InUse */) {\n                            b[j] = bNode = directClone(bNode);\n                        }\n                        patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n                        ++patched;\n                    }\n                    else if (!canRemoveWholeContent) {\n                        remove(aNode, dom);\n                    }\n                }\n                else if (!canRemoveWholeContent) {\n                    remove(aNode, dom);\n                }\n            }\n        }\n        // fast-path: if nothing patched remove all old and add all new\n        if (canRemoveWholeContent) {\n            removeAllChildren(dom, parentVNode, a);\n            mountArrayChildren(b, dom, context, isSVG, outerEdge, lifecycle);\n        }\n        else if (moved) {\n            var seq = lis_algorithm(sources);\n            j = seq.length - 1;\n            for (i = bLeft - 1; i >= 0; i--) {\n                if (sources[i] === 0) {\n                    pos = i + bStart;\n                    bNode = b[pos];\n                    if (bNode.flags & 16384 /* InUse */) {\n                        b[pos] = bNode = directClone(bNode);\n                    }\n                    nextPos = pos + 1;\n                    mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);\n                }\n                else if (j < 0 || i !== seq[j]) {\n                    pos = i + bStart;\n                    bNode = b[pos];\n                    nextPos = pos + 1;\n                    moveVNodeDOM(bNode, dom, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge);\n                }\n                else {\n                    j--;\n                }\n            }\n        }\n        else if (patched !== bLeft) {\n            // when patched count doesn't match b length we need to insert those new ones\n            // loop backwards so we can use insertBefore\n            for (i = bLeft - 1; i >= 0; i--) {\n                if (sources[i] === 0) {\n                    pos = i + bStart;\n                    bNode = b[pos];\n                    if (bNode.flags & 16384 /* InUse */) {\n                        b[pos] = bNode = directClone(bNode);\n                    }\n                    nextPos = pos + 1;\n                    mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);\n                }\n            }\n        }\n    }\n}\nvar result;\nvar p;\nvar maxLen = 0;\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\nfunction lis_algorithm(arr) {\n    var arrI = 0;\n    var i = 0;\n    var j = 0;\n    var k = 0;\n    var u = 0;\n    var v = 0;\n    var c = 0;\n    var len = arr.length;\n    if (len > maxLen) {\n        maxLen = len;\n        result = new Int32Array(len);\n        p = new Int32Array(len);\n    }\n    for (; i < len; ++i) {\n        arrI = arr[i];\n        if (arrI !== 0) {\n            j = result[k];\n            if (arr[j] < arrI) {\n                p[i] = j;\n                result[++k] = i;\n                continue;\n            }\n            u = 0;\n            v = k;\n            while (u < v) {\n                c = (u + v) >> 1;\n                if (arr[result[c]] < arrI) {\n                    u = c + 1;\n                }\n                else {\n                    v = c;\n                }\n            }\n            if (arrI < arr[result[u]]) {\n                if (u > 0) {\n                    p[i] = result[u - 1];\n                }\n                result[u] = i;\n            }\n        }\n    }\n    u = i = k + 1;\n    var seq = new Int32Array(u);\n    v = result[u - 1];\n    while (u-- > 0) {\n        seq[u] = v;\n        v = p[v];\n    }\n    while (i-- > 0) {\n        result[i] = 0;\n    }\n    return seq;\n}\n\nvar hasDocumentAvailable = typeof document !== 'undefined';\nvar documentBody = null;\nif (hasDocumentAvailable) {\n    documentBody = document.body;\n    /*\n     * Defining $EV and $V properties on Node.prototype\n     * fixes v8 \"wrong map\" de-optimization\n     */\n    Node.prototype.$EV = null;\n    Node.prototype.$V = null;\n}\nfunction __render(input, parentDOM, callback, context) {\n    var lifecycle = [];\n    var rootInput = parentDOM.$V;\n    renderCheck.v = true;\n    if (isNullOrUndef(rootInput)) {\n        if (!isNullOrUndef(input)) {\n            if (input.flags & 16384 /* InUse */) {\n                input = directClone(input);\n            }\n            mount(input, parentDOM, context, false, null, lifecycle);\n            parentDOM.$V = input;\n            rootInput = input;\n        }\n    }\n    else {\n        if (isNullOrUndef(input)) {\n            remove(rootInput, parentDOM);\n            parentDOM.$V = null;\n        }\n        else {\n            if (input.flags & 16384 /* InUse */) {\n                input = directClone(input);\n            }\n            patch(rootInput, input, parentDOM, context, false, null, lifecycle);\n            rootInput = parentDOM.$V = input;\n        }\n    }\n    if (lifecycle.length > 0) {\n        callAll(lifecycle);\n    }\n    renderCheck.v = false;\n    if (isFunction(callback)) {\n        callback();\n    }\n    if (isFunction(options.renderComplete)) {\n        options.renderComplete(rootInput, parentDOM);\n    }\n}\nfunction render(input, parentDOM, callback, context) {\n    if ( callback === void 0 ) callback = null;\n    if ( context === void 0 ) context = EMPTY_OBJ;\n\n    __render(input, parentDOM, callback, context);\n}\nfunction createRenderer(parentDOM) {\n    return function renderer(lastInput, nextInput, callback, context) {\n        if (!parentDOM) {\n            parentDOM = lastInput;\n        }\n        render(nextInput, parentDOM, callback, context);\n    };\n}\n\nvar QUEUE = [];\nvar nextTick = typeof Promise !== 'undefined' ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout.bind(window);\nvar microTaskPending = false;\nfunction queueStateChanges(component, newState, callback, force) {\n    var pending = component.$PS;\n    if (isFunction(newState)) {\n        newState = newState(pending ? combineFrom(component.state, pending) : component.state, component.props, component.context);\n    }\n    if (isNullOrUndef(pending)) {\n        component.$PS = newState;\n    }\n    else {\n        for (var stateKey in newState) {\n            pending[stateKey] = newState[stateKey];\n        }\n    }\n    if (!component.$BR) {\n        if (!renderCheck.v) {\n            if (QUEUE.length === 0) {\n                applyState(component, force, callback);\n                return;\n            }\n        }\n        if (QUEUE.indexOf(component) === -1) {\n            QUEUE.push(component);\n        }\n        if (!microTaskPending) {\n            microTaskPending = true;\n            nextTick(rerender);\n        }\n        if (isFunction(callback)) {\n            var QU = component.$QU;\n            if (!QU) {\n                QU = component.$QU = [];\n            }\n            QU.push(callback);\n        }\n    }\n    else if (isFunction(callback)) {\n        component.$L.push(callback.bind(component));\n    }\n}\nfunction callSetStateCallbacks(component) {\n    var queue = component.$QU;\n    for (var i = 0, len = queue.length; i < len; ++i) {\n        queue[i].call(component);\n    }\n    component.$QU = null;\n}\nfunction rerender() {\n    var component;\n    microTaskPending = false;\n    while ((component = QUEUE.pop())) {\n        var queue = component.$QU;\n        applyState(component, false, queue ? callSetStateCallbacks.bind(null, component) : null);\n    }\n}\nfunction applyState(component, force, callback) {\n    if (component.$UN) {\n        return;\n    }\n    if (force || !component.$BR) {\n        var pendingState = component.$PS;\n        component.$PS = null;\n        var lifecycle = [];\n        renderCheck.v = true;\n        updateClassComponent(component, combineFrom(component.state, pendingState), component.props, findDOMfromVNode(component.$LI, true).parentNode, component.context, component.$SVG, force, null, lifecycle);\n        if (lifecycle.length > 0) {\n            callAll(lifecycle);\n        }\n        renderCheck.v = false;\n    }\n    else {\n        component.state = component.$PS;\n        component.$PS = null;\n    }\n    if (isFunction(callback)) {\n        callback.call(component);\n    }\n}\nvar Component = function Component(props, context) {\n    // Public\n    this.state = null;\n    // Internal properties\n    this.$BR = false; // BLOCK RENDER\n    this.$BS = true; // BLOCK STATE\n    this.$PS = null; // PENDING STATE (PARTIAL or FULL)\n    this.$LI = null; // LAST INPUT\n    this.$UN = false; // UNMOUNTED\n    this.$CX = null; // CHILDCONTEXT\n    this.$QU = null; // QUEUE\n    this.$N = false; // Uses new lifecycle API Flag\n    this.$L = null; // Current lifecycle of this component\n    this.$SVG = false; // Flag to keep track if component is inside SVG tree\n    this.props = props || EMPTY_OBJ;\n    this.context = context || EMPTY_OBJ; // context should not be mutable\n};\nComponent.prototype.forceUpdate = function forceUpdate (callback) {\n    if (this.$UN) {\n        return;\n    }\n    // Do not allow double render during force update\n    queueStateChanges(this, {}, callback, true);\n};\nComponent.prototype.setState = function setState (newState, callback) {\n    if (this.$UN) {\n        return;\n    }\n    if (!this.$BS) {\n        queueStateChanges(this, newState, callback, false);\n    }\n    else {\n        return;\n    }\n};\nComponent.prototype.render = function render (_nextProps, _nextState, _nextContext) {\n    return null;\n};\n\nvar version = \"7.1.10\";\n\n\n\n\n//# sourceURL=webpack:///./node_modules/inferno/dist/index.esm.js?");

/***/ }),

/***/ "./node_modules/inferno/index.esm.js":
/*!*******************************************!*\
  !*** ./node_modules/inferno/index.esm.js ***!
  \*******************************************/
/*! exports provided: Component, Fragment, EMPTY_OBJ, createComponentVNode, createFragment, createPortal, createRef, createRenderer, createTextVNode, createVNode, forwardRef, directClone, findDOMfromVNode, getFlagsForElementVnode, linkEvent, normalizeProps, options, render, rerender, version, _CI, _HI, _M, _MCCC, _ME, _MFCC, _MR, _MT, _MP, __render */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.esm.js */ \"./node_modules/inferno/dist/index.esm.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"Component\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Fragment\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"Fragment\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EMPTY_OBJ\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"EMPTY_OBJ\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createComponentVNode\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createComponentVNode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createFragment\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createFragment\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createPortal\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createPortal\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createRef\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createRef\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createRenderer\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createRenderer\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createTextVNode\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createTextVNode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createVNode\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createVNode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"forwardRef\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"forwardRef\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"directClone\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"directClone\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"findDOMfromVNode\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"findDOMfromVNode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getFlagsForElementVnode\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"getFlagsForElementVnode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"linkEvent\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"linkEvent\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"normalizeProps\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"normalizeProps\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"options\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"options\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"render\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"rerender\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"rerender\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"version\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"version\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"_CI\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"_CI\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"_HI\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"_HI\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"_M\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"_M\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"_MCCC\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"_MCCC\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"_ME\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"_ME\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"_MFCC\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"_MFCC\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"_MR\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"_MR\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"_MT\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"_MT\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"_MP\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"_MP\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__render\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"__render\"]; });\n\n\n\nif (true) {\n  console.warn('You are running production build of Inferno in development mode. Use dev:module entry point.');\n}\n\n\n//# sourceURL=webpack:///./node_modules/inferno/index.esm.js?");

/***/ }),

/***/ "./src/font-style.js":
/*!***************************!*\
  !*** ./src/font-style.js ***!
  \***************************/
/*! exports provided: title, formalityName, formalitySubtitle, text, subtitle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"title\", function() { return title; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"formalityName\", function() { return formalityName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"formalitySubtitle\", function() { return formalitySubtitle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"text\", function() { return text; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtitle\", function() { return subtitle; });\nconst primaryColor = \"#444053\";\n\nconst formalityName = {\n  \"font-size\": \"80px\",\n  \"color\": primaryColor,\n  \"margin-top\": \"200px\"\n}   \n\nconst formalitySubtitle = {\n  \"font-size\": \"25px\",\n  \"font-family\": 'Open Sans',\n  \"color\": \"#444053\"\n}\n\nconst title = {\n  \"width\": \"100%\",\n  \"height\": \"100px\",\n  \"display\": \"flex\",\n  \"justify-content\": \"center\",\n  \"font-size\" : \"40px\",\n  \"align-items\": \"center\",\n  \"font-family\": \"Open Sans\",\n  \"color\": primaryColor,\n  \"top\": \"25px\",\n  \"position\": \"relative\",\n}\n\nconst text = {\n  \"padding\": \"40px\",\n  \"font-size\": \"15px\",\n  \"font-family\": \"Open Sans\",\n  \"color\": primaryColor,\n  \"line-height\": \"1.6\",\n  \"text-align\": \"justify\",\n}\n\nconst subtitle = {\n  ...text, \n  \"font-size\": \"20px\",\n  \"width\": \"800px\",\n  \"margin-top\": \"20px\",\n  \"text-align\": \"center\", \n  \"line-height\": \"1.6\",\n}\n\n\n\n\n//# sourceURL=webpack:///./src/font-style.js?");

/***/ }),

/***/ "./src/images/code.png":
/*!*****************************!*\
  !*** ./src/images/code.png ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"src/images/code.png\";\n\n//# sourceURL=webpack:///./src/images/code.png?");

/***/ }),

/***/ "./src/images/development-page.png":
/*!*****************************************!*\
  !*** ./src/images/development-page.png ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"src/images/development-page.png\";\n\n//# sourceURL=webpack:///./src/images/development-page.png?");

/***/ }),

/***/ "./src/images/fast.png":
/*!*****************************!*\
  !*** ./src/images/fast.png ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"src/images/fast.png\";\n\n//# sourceURL=webpack:///./src/images/fast.png?");

/***/ }),

/***/ "./src/images/formality-bg-2.jpg":
/*!***************************************!*\
  !*** ./src/images/formality-bg-2.jpg ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"src/images/formality-bg-2.jpg\";\n\n//# sourceURL=webpack:///./src/images/formality-bg-2.jpg?");

/***/ }),

/***/ "./src/images/formality-title.png":
/*!****************************************!*\
  !*** ./src/images/formality-title.png ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"src/images/formality-title.png\";\n\n//# sourceURL=webpack:///./src/images/formality-title.png?");

/***/ }),

/***/ "./src/images/github.png":
/*!*******************************!*\
  !*** ./src/images/github.png ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"src/images/github.png\";\n\n//# sourceURL=webpack:///./src/images/github.png?");

/***/ }),

/***/ "./src/images/logo-formality.png":
/*!***************************************!*\
  !*** ./src/images/logo-formality.png ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"src/images/logo-formality.png\";\n\n//# sourceURL=webpack:///./src/images/logo-formality.png?");

/***/ }),

/***/ "./src/images/math.png":
/*!*****************************!*\
  !*** ./src/images/math.png ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"src/images/math.png\";\n\n//# sourceURL=webpack:///./src/images/math.png?");

/***/ }),

/***/ "./src/images/usageBg2.png":
/*!*********************************!*\
  !*** ./src/images/usageBg2.png ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"src/images/usageBg2.png\";\n\n//# sourceURL=webpack:///./src/images/usageBg2.png?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _images_formality_title_png__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./images/formality-title.png */ \"./src/images/formality-title.png\");\n/* harmony import */ var _images_formality_title_png__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_images_formality_title_png__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _images_math_png__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./images/math.png */ \"./src/images/math.png\");\n/* harmony import */ var _images_math_png__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_images_math_png__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _images_fast_png__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./images/fast.png */ \"./src/images/fast.png\");\n/* harmony import */ var _images_fast_png__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_images_fast_png__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _images_code_png__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./images/code.png */ \"./src/images/code.png\");\n/* harmony import */ var _images_code_png__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_images_code_png__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _images_logo_formality_png__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./images/logo-formality.png */ \"./src/images/logo-formality.png\");\n/* harmony import */ var _images_logo_formality_png__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_images_logo_formality_png__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _images_github_png__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./images/github.png */ \"./src/images/github.png\");\n/* harmony import */ var _images_github_png__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_images_github_png__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _images_development_page_png__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./images/development-page.png */ \"./src/images/development-page.png\");\n/* harmony import */ var _images_development_page_png__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_images_development_page_png__WEBPACK_IMPORTED_MODULE_6__);\nconst {Component, render, linkEvent} = __webpack_require__(/*! inferno */ \"./node_modules/inferno/index.esm.js\");\nconst h = __webpack_require__(/*! inferno-hyperscript */ \"./node_modules/inferno-hyperscript/dist/index.esm.js\").h;\nconst Canvas = __webpack_require__(/*! inferno-canvas-component-2 */ \"./node_modules/inferno-canvas-component-2/inferno-canvas-component.js\");\n\n// Formality\nconst f = __webpack_require__(/*! formality-lang */ \"./node_modules/formality-lang/index.js\");\n\n// Style\nconst s = __webpack_require__(/*! ./style */ \"./src/style.js\");\nconst fs = __webpack_require__(/*! ./font-style */ \"./src/font-style.js\");\n\n// MD Resources\nconst markdown = __webpack_require__(/*! ./markdown/test-template.md.js */ \"./src/markdown/test-template.md.js\");\nconst ovGettingStartedMD = __webpack_require__(/*! ./markdown/overview/1.GettingStarted.js */ \"./src/markdown/overview/1.GettingStarted.js\");\nconst ovExamplesMD = __webpack_require__(/*! ./markdown/overview/2.Examples.js */ \"./src/markdown/overview/2.Examples.js\");\nconst ovFAQMD = __webpack_require__(/*! ./markdown/overview/3.FAQ.js */ \"./src/markdown/overview/3.FAQ.js\");\n\n// Pages\nconst pageHome = \"home\";\nconst pageWhyContent1 = \"math-proof\";\nconst pageWhyContent2 = \"massive-paralelism\";\nconst pageDocumentation = \"documentation\";\nconst pageTryIt = \"tryIt\";\n\nconst pageOverview = \"overview\";\nconst pageOVGettingStarted = \"overview/getting-started\";\nconst pageExamples = \"overview/examples\";\nconst pageOVFAQ = \"overview/FAQ\";\n// TODO: add the other pages (Interaction Combinators, EAC, etc)\n\n\n// Feature images\n\n\n\n\n\n\n\n\nclass Site extends Component {\n  constructor(props) {\n    super(props)\n    this.state = {page: \"home\"};\n  }\n\n  componentDidMount(){\n    switch (window.location.pathname) {\n      case \"/\"+pageHome: this.setState({page: pageHome}); break;\n      case \"/\"+pageDocumentation: this.setState({page: pageDocumentation}); break;\n      case \"/\"+pageTryIt: this.setState({page: pageTryIt});\n      case \"/\"+pageWhyContent1: this.setState({page: pageWhyContent1}); break;\n      case \"/\"+pageWhyContent2: this.setState({page: pageWhyContent2}); break;\n\n      case \"/\"+pageOverview: this.setState({page: pageOverview}); break;\n      case \"/\"+pageOVGettingStarted: this.setState({page: pageOVGettingStarted}); console.log(\"> Did mount in case /overview/getting-started\"); break;\n      // TODO: add the other pages (Interaction Combinators, EAC, etc)\n    }\n\n    window.onpopstate = (event) => {\n      if (event.state !== null) {\n        var prevPage = event.state.page;\n        if (this.state.page !== prevPage) {\n          this.setState({page: prevPage});\n        }\n      } else { // go Home\n        this.setState({page: pageHome});\n      }\n    }\n  }\n\n  onChangeInternalLink(nextPage) {\n    history.pushState({page: nextPage}, nextPage, nextPage);\n    this.setState({page: nextPage});\n    window.scrollTo(0, 0);\n  }\n\n  render() {\n    // function drawCanvas({ctx, time}) {\n    //     const {width, height} = ctx.canvas;\n    //     ctx.save();\n    //     ctx.clearRect(0, 0, width, height);\n    //     ctx.fillStyle = 'black';\n    //     ctx.translate(width / 2, height / 2);\n    //     ctx.rotate(((time / 10) % 360) * Math.PI / 180);\n    //     ctx.fillRect(-1 * width / 4, -1 * height / 4, width / 2, height / 2);\n    //     ctx.restore();\n    // }\n\n    const formalityTitleContainer = {\n      \"width\": \"650px\",\n      \"height\": \"85px\",\n      \"object-fit\": \"cover\",\n      \"background-repeat\": \"no-repeat, repeat\",\n      \"background-size\": \"cover\",\n      \"display\": \"flex\",\n      \"flex-flow\": \"column nowrap\",\n      \"justify-content\": \"flex-start\",\n      \"align-items\": \"center\",\n      \"background-image\": \"url(src/images/formality-title.png)\",\n      \"margin-top\": \"200px\",\n      \"margin-bottom\": \"30px\"\n    }\n\n    const genericContentContainer = { \"min-height\": \"1000px\", \"flex-direction\": \"column\", \"margin-bottom\": \"60px\"}\n    // Top menu\n    var topMenu = h(\"div\", {style: {\"width\": \"100%\", \"display\": \"flex\", \"flex-flow\": \"row nowrap\", \"background-color\": s.primaryColor, \"color\": s.secondaryColor}}, [\n      h(Logo, {onClick: () => {\n        if (this.state.page !== pageHome) {\n          this.setState({page: pageHome});\n          history.pushState({page: pageHome}, \"/\"+pageHome, \"/\"+pageHome);\n        }\n      }}),\n      h(\"div\", {style: {\"width\": \"100%\", \"height\": \"30px\", \"margin-top\": \"10px\", \"display\": \"flex\", \"justify-content\": \"flex-end\", \"align-items\": \"center\", \"margin-right\": \"200px\"}}, [\n        h(Tab, {title: \"Overview\", isCurrentPage: this.state.page === pageOverview,\n                onClick: () => {\n                  if (this.state.page !== pageOverview) {\n                    this.setState({page: pageOverview});\n                    history.pushState({page: pageOverview}, \"/\"+pageOverview, \"/\"+pageOverview);\n                  }\n                }\n              }),\n        h(Tab, {title: \"Documentation\", isCurrentPage: this.state.page === pageDocumentation,\n                onClick: () => {\n                  if (this.state.page !== pageDocumentation) {\n                    this.setState({page: pageDocumentation});\n                    history.pushState({page: pageDocumentation}, \"/\"+pageDocumentation, \"/\"+pageDocumentation);\n                  }\n                }\n              }),\n        h(Tab, {title: \"Try it!\", isCurrentPage: this.state.page === pageTryIt,\n                onClick: () => {\n                    if (this.state.page !== pageTryIt) {\n                      this.setState({page: pageTryIt});\n                      history.pushState({page: pageTryIt}, \"/\"+pageTryIt, \"/\"+pageTryIt);\n                    }\n                }\n              })\n      ]),\n    ])\n\n    // ============= Home =============\n    if (this.state.page === pageHome || this.state.page === null ) {\n      return h(\"div\", [\n        topMenu,\n        // Top area: Formality title and subtitle\n        h(\"div\", {style: s.topContainer}, [\n          h(\"div\", {style: formalityTitleContainer}),\n          h(\"div\", {style: fs.formalitySubtitle}, [\n            h(\"span\", {style: {\"font-family\": 'Open Sans' }}, \"An efficient\\u00A0\"),\n            h(\"span\", {style: {\"font-family\": 'Open Sans', \"font-weight\": \"bold\"}}, \"proof\"),\n            h(\"span\", {style: {\"font-family\": 'Open Sans' }}, \"gramming language\"),\n          ]),\n          h(Button, {title: \"Try it\", onClick: () => { this.setState({page: pageTryIt}); window.scrollTo(0, 0); }}),\n        ]),\n\n        // Canvas test\n        // h(Canvas, {draw: drawCanvas, width: 200, height: 200, realtime: true})\n        h(Introduction),\n        h(WhyGrid, {changePage: this.onChangeInternalLink.bind(this)}),\n        h(Usage,{}),\n        h(Footer, {})\n      ]);\n\n    // ============= Overview Page =============\n    } else if (this.state.page === pageOverview) {\n      return h(\"div\", {\"display\": \"flex\", \"justify-content\": \"space-between\"}, [\n        topMenu,\n        h(\"div\", {style: genericContentContainer}, [\n         h(Overview, {page: pageOverview})\n        ]),\n         h(FooterContainer),\n      ]);\n\n\n    // ============= Documentation Page =============\n    } else if (this.state.page === pageDocumentation) {\n      return h(\"div\", {\"display\": \"flex\", \"justify-content\": \"space-between\"}, [\n        topMenu,\n        h(\"div\", {style: genericContentContainer}, [\n          h(Documentation, {page: pageDocumentation})\n         ]),\n         h(FooterContainer),\n      ]);\n\n    // ============= Try it Page =============\n    } else if (this.state.page === pageTryIt) {\n      return h(\"div\", {\"display\": \"flex\", \"justify-content\": \"space-between\"}, [\n        topMenu,\n        h(\"div\", {style: {\"height\": \"1000px\", \"flex-direction\": \"column\", \"justify-content\": \"center\", \"align-items\": \"center\",}}, [\n            h(TryIt)\n        ]),\n        h(FooterContainer),\n      ]);\n\n    // ============= Why content 1 =============\n    } else if (this.state.page === pageWhyContent1) {\n      return h(\"div\", {\"display\": \"flex\", \"justify-content\": \"space-between\"}, [\n        topMenu,\n        h(\"div\", {style: {\"height\": \"1000px\", \"flex-direction\": \"column\", \"justify-content\": \"center\", \"align-items\": \"center\",}}, [\n          h(\"div \", {style: s.pageContentMD}, [\n            h(DevelopmentPage)\n          ]),\n        ]),\n        h(FooterContainer),\n      ]);\n    // ============= Why content 2 =============\n    } else if (this.state.page === pageWhyContent2) {\n      return h(\"div\", {\"display\": \"flex\", \"justify-content\": \"space-between\"}, [\n        topMenu,\n        h(\"div\", {style: {\"height\": \"1000px\", \"flex-direction\": \"column\", \"justify-content\": \"center\", \"align-items\": \"center\",}}, [\n          h(\"div \", {style: s.pageContentMD}, [\n            h(DevelopmentPage)\n          ]),\n        ]),\n        h(FooterContainer),\n      ]);\n    } else if (this.state.page === pageOVGettingStarted) {\n      return h(\"div\", {\"display\": \"flex\", \"justify-content\": \"space-between\"}, [\n        topMenu,\n        h(\"div\", {style: genericContentContainer}, [\n         h(Overview, {page: pageOVGettingStarted})\n        ]),\n         h(FooterContainer),\n      ]);\n    } else if (this.state.page === pageExamples) {\n      return h(\"div\", {\"display\": \"flex\", \"justify-content\": \"space-between\"}, [\n        topMenu,\n        h(\"div\", {style: genericContentContainer}, [\n          h(Overview, {page: pageExamples})\n        ]),\n          h(FooterContainer),\n      ]);\n    }\n  }\n}\n\nclass Documentation extends Component {\n  constructor(props){\n    super(props)\n    this.state = {page: props.page};\n  }\n  isCurrentPage(id) {\n    return this.state.page === id;\n  }\n  render(){\n    const contentNavigator = \n      h(ContentNavigatorContainer, {items: [\n        h(ContentNavigatorItem, {title: \"LEARN THE LANGUAGE\", isMainTopic: true}),\n        h(ContentNavigatorItem, {title: \"Syntax\", onClick: () => {\n          if (this.state.page !== \"\") {\n            // this.setState({ page: pageOVGettingStarted });\n            // history.pushState({ page: pageOVGettingStarted }, \"/\"+pageOVGettingStarted, \"/\"+pageOVGettingStarted);\n          }\n        }, isCurrentPage: this.isCurrentPage(pageOVGettingStarted)}),\n        h(ContentNavigatorItem, {title: \"Functions\"}),\n        h(ContentNavigatorItem, {title: \"Erasure to EAC\", onClick: () => {\n          if (this.state.page !== \"\") {\n            // this.setState({ page: pageOVFAQ });\n            // history.pushState({ page: pageOVFAQ }, \"/\"+pageOVFAQ, \"/\"+pageOVFAQ);\n          }\n        }, isCurrentPage: this.isCurrentPage(pageOVFAQ)}),\n        h(ContentNavigatorItem, {title: \"Reduction Rules\"}),\n        h(ContentNavigatorItem, {title: \"Typing rules\"}),\n      ]});\n\n    const contentNavigatorStyle = {\n      \"margin-left\": \"200px\", \n      \"margin-right\": \"200px\", \n      \"margin-top\": \"60px\",\n      \"display\": \"flex\",\n      \"flex-direction\": \"row\",\n      \"justify-content\": \"flex-start\",\n    }\n   \n    // if (this.props.page === pageExamples) {\n    //   console.log(\"Rendering pageExamples\");\n    //   return h(\"div\", {style: contentNavigatorStyle}, [\n    //           contentNavigator,\n    //           h(DocsMarkdownContainer, {mdResource: ovExamplesMD}) \n    //         ]);\n    // } else {\n      return h(\"div\", {style: contentNavigatorStyle}, [\n        contentNavigator,\n        h(DocsMarkdownContainer, {mdResource: markdown})   \n      ])\n    // }\n\n  }\n}\n\n\n// ============= Auxiliars =============\n\nclass Logo extends Component {\n  constructor(props) {\n    super(props)\n    this.onClick = props.onClick;\n    this.state = {};\n  }\n  render() {\n    const logoStyle = {\n      \"width\" : \"45px\",\n      \"height\" : \"40px\",\n      \"margin-left\" : \"200px\",\n      \"margin-top\" : \"10px\", \n      \"margin-bottom\" : \"10px\",\n      \"cursor\": \"pointer\"\n    }\n    return h(\"img\", {src: _images_logo_formality_png__WEBPACK_IMPORTED_MODULE_4___default.a, alt: \"logo\", style: logoStyle, onClick: this.onClick});\n  }\n}\n\nclass Tab extends Component {\n  constructor(props) {\n    super(props)\n    this.onClick = props.onClick;\n    this.isCurrentPage = props.isCurrentPage;\n    this.title = props.title;\n    this.state = {};\n  }\n\n  render() {\n    var element;\n    if (this.props.isCurrentPage) {\n      element = h(\"div\", {style: s.tabsOnFocus, onClick: this.onClick}, this.props.title)\n    } else {\n      element = h(Hover, {normalComponent: h(\"div\", {style: s.tabs, isCurrentPage: this.isCurrentPage },  this.props.title),\n                          onFocusComponent: h(\"div\", {style: s.tabsOnFocus, onClick: this.onClick}, this.props.title)})\n    }\n    return element;\n  }\n}\n\nclass Button extends Component {\n  constructor(props) {\n    super(props)\n    this.title = props.title;\n    this.onClick = props.onClick;\n    this.state = {};\n  }\n  render() {\n    const tryItButton = {\n      \"width\": \"100px\",\n      \"height\": \"50px\",\n      \"display\": \"flex\",\n      \"justify-content\": \"center\",\n      \"font-size\": \"20px\",\n      \"margin-top\": \"60px\",\n      \"color\": s.primaryColor,\n      \"border\": \"2px solid #444053\",\n      \"border-radius\": \"25px\",\n      \"background-color\": s.secondaryColor,\n    }\n\n    const tryItButtonOnFocus = {\n      ...tryItButton,\n      \"color\": s.secondaryColor,\n      \"background-color\": s.primaryColor,\n      \"cursor\": \"pointer\",\n    }\n\n    return h(Hover, {normalComponent: h(\"button\", {style: tryItButton, onClick: this.onClick}, this.props.title),\n                    onFocusComponent: h(\"button\", {style: tryItButtonOnFocus, onClick: this.onClick}, this.props.title)});\n  }\n}\n\nclass Hover extends Component {\n  constructor(props) {\n    super(props)\n    this.state = {isOnFocus: false, normalComponent: props.normalComponent, onFocusComponent: props.onFocusComponent};\n  }\n\n  render() {\n    const component = this.state.isOnFocus ? this.state.onFocusComponent : this.state.normalComponent ;\n\n    return h(\"div\",\n      {onMouseEnter: () => this.setState(this.state.isOnFocus = true),\n      onMouseLeave: () => this.setState(this.state.isOnFocus = false)},\n      component);\n  }\n}\n\nclass DevelopmentPage extends Component {\n  render() {\n    const container = {\n      \"height\": \"500px\",\n      \"display\": \"flex\",\n      \"flex-direction\": \"column\",\n      \"justify-content\": \"center\",\n      \"align-items\": \"center\",\n      \"font-family\": \"Open Sans\",\n      \"color\": s.primaryColor,\n      \"font-size\": \"20px\",\n    }\n    const image = {\n      \"width\" : \"400px\",\n      \"height\" : \"300px\",\n    }\n    return h(\"div\", {style: container}, [\n      h(\"p\", {style: {\"margin-bottom\": \"10px\"}}, \"We are still working on this page :)\"),\n      h(\"img\", {src: _images_development_page_png__WEBPACK_IMPORTED_MODULE_6___default.a, alt: \"development\", style: image})\n    ]);\n  }\n}\n\n// Read more is used in Why content\nclass ReadMoreLink extends Component {\n  constructor(props){\n    super(props)\n    this.onClick = props.onClick;\n    this.title = props.title;\n    this.state = {};\n  }\n  render(){\n    return h(\"p\", {style: {\"cursor\": \"pointer\", \"margin-top\": \"15px\"}, onClick: this.onClick}, this.title);\n  }\n}\n\n// Link to a page inside of the website\nclass InternalLink extends Component {\n  constructor(props) {\n    super(props)\n    this.onClick = props.onClick;\n    this.title = props.title;\n    this.color = props.color;\n  }\n\n  render(){\n    if (this.props.color) {\n      return h(\"span\", {style: {\"cursor\": \"pointer\", \"color\": this.props.color}, onClick: this.onClick}, this.title);\n    } else {\n      return h(\"span\", {style: {\"cursor\": \"pointer\", \"color\": \"#68c3d4\"}, onClick: this.onClick}, this.title);\n    }\n    \n  }\n}\n\n// ------------ Content -------------\n// A container to hold all elements used for the content navigation\nclass ContentNavigatorContainer extends Component {\n  constructor(props) {\n    super(props)\n    this.items = props.items;\n  }\n  render(){\n    return h(\"div\", {style: {\"width\": \"150px\", \"height\": \"300px\", \"margin-right\": \"40px\", \"margin-top\": \"50px\"}}, this.props.items)\n  }\n}\n\n// A navigation item has a Content Title and load the text correspondent to that subject\nclass ContentNavigatorItem extends Component {\n  constructor(props) {\n    super(props)\n    this.onClick = props.onClick;\n    this.childs = props.childs;\n    this.title = props.title;\n    this.isMainTopic = props.isMainTopic;\n    this.state = {isExpanded: props.isExpanded, isCurrentPage: props.isCurrentPage = false}\n  }\n  render(){\n    const normalComponentStyle = {\n      \"font-family\": \"Open Sans\", \n      \"font-size\": \"14px\", \n      \"color\": s.shadowBlue,\n      \"margin-bottom\": \"10px\",\n    }\n    const onFocusComponentStyle = { ...normalComponentStyle, \"cursor\": \"pointer\", \"color\": s.primaryColor}\n\n    if (this.props.isMainTopic) {\n      return h(\"p\", {style: {...normalComponentStyle, \"font-weight\": \"bold\"}}, this.props.title);\n    } else {\n      if (this.props.isCurrentPage) {\n        return h(\"p\", {onClick: this.onClick, style: {...onFocusComponentStyle, \"font-weight\": \"bold\"}}, this.props.title);\n      } else {\n        return h(Hover, {normalComponent: h(\"p\", {style: normalComponentStyle}, this.props.title), \n        onFocusComponent: h(\"p\", {onClick: this.onClick, style: onFocusComponentStyle}, this.props.title)});\n      }\n    }\n  }\n}\n\n// A markdown container to be used with the ContentNavigatorContainer structure\nclass DocsMarkdownContainer extends Component {\n  constructor(props){\n    super(props)\n    this.mdResource = props.mdResource;\n  }\n\n  render() {\n    return h(\"div\", {style: {\"display\": \"flex\", \"flex-direction\": \"column\", \"width\": \"900px\",\n    \"justify-content\": \"flex-start\", \"font-family\": \"Open Sans\", \"color\": \"#373530\", \"line-height\": \"1.6\"}}, this.props.mdResource)\n  }\n}\n\n// ============= Home Page =============\n\nclass Introduction extends Component {\n  constructor(props){\n    super(props)\n    state: {}\n  }\n\n  render() {\n    const container = {\n      \"display\": \"flex\",\n      \"flex-direction\": \"column\",\n      \"justify-content\": \"center\",\n      \"align-items\": \"center\",\n      \"height\": \"300px\",\n    }\n\n    const subtitle = {\n      ...fs.subtitle,\n      \"line-height\": \"1.8\",\n    }\n\n    return h(\"div\", {style: container }, [\n        h(\"p\", {style: subtitle}, `Formality is a new, massively parallel, minimal proofgramming language being developed at the Ethereum Foundation.\n        It has an ambitious goal of redefining how programs, smart-contracts and even scientific papers are written, by combining several academic breakthroughs in a single tool that just works.`),\n    ]);\n  }\n}\n\n// Content about why use Formality\nclass WhyGrid extends Component {\n  constructor(props) {\n    super(props)\n    this.onClick = props.onClick;\n    this.state = {};\n  }\n\n  onChangeLink(nextPage) {\n    this.props.changePage(nextPage);\n  }\n\n  render() {\n    const gridContainer = {\n      \"display\": \"flex\",\n      \"flex-direction\": \"column\",\n      \"justify-content\": \"center\",\n      \"align-items\": \"center\",\n    }\n\n    const gridItem = {\n      \"display\": \"flex\",\n      \"height\": \"350px\",\n      \"width\": \"800px\",\n      \"align-items\": \"center\",\n      \"font-size\": \"22px\"\n    }\n\n    const featureImg =  {\n      \"border-radius\": \"8px\",\n      \"width\": \"300px\"\n    }\n\n    return h(\"div\", {style: gridContainer}, [\n      h(\"div\", {style: fs.title}, \"Why use Formality?\"),\n      // First element\n      h(\"div\", {style: gridItem}, [\n        h(\"div\", {style: fs.text, \"width\": \"300px\"}, [\n          h(\"p\", {style: {\"font-size\": \"25px\", \"margin-bottom\": \"10px\"}}, \"Secure\"),\n          h(\"p\", {}, `Formality has a type system capable of proving mathematical theorems about its own programs.\n          It's not only about preventing bugs or proving the theorem itself. We are talking about a whole new tool to work with,\n          a language of specifications, one on which we can state precisely, in a way that a computer can understand, what an algorithm is supposed to do.  `),\n          h(\"p\", {style: {\"margin-top\": \"5px\", \"margin-bottom\": \"8px\"}}, \"This opens doors for use-cases that are only limited by your imagination!\"),\n          h(InternalLink, {title: \"Read more...\", onClick: this.onChangeLink.bind(this, pageWhyContent1), color: s.primaryColor }),\n        ]),\n        h(\"img\", {src: _images_math_png__WEBPACK_IMPORTED_MODULE_1___default.a, alt: \"image1\", style: featureImg})\n      ]),\n      // Second element\n      h(\"div\", {style: gridItem}, [\n        h(\"div\", {style: fs.text, \"width\": \"300px\"},[\n          h(\"p\", {style: {\"font-size\": \"25px\", \"margin-bottom\": \"10px\"}}, \"Fast\"),\n          h(\"p\", {}, \"No garbage-collection,optimal beta-reductionand a massively parallel GPU compiler make itinsanely fast.\"),\n          h(\"p\", {style: {\"margin-bottom\": \"8px\"}}, \"Massively parallel evaluation is possible due to Symmetric Interaction Calculus (SIC), a new model of computation that combines the best aspects of the Turing Machine and the -Calculus.\"),\n          h(InternalLink, {title: \"Read more...\", onClick: this.onChangeLink.bind(this, pageWhyContent2), color: s.primaryColor }),\n        ]),\n        h(\"img\", {src: _images_fast_png__WEBPACK_IMPORTED_MODULE_2___default.a, alt: \"image2\", style: featureImg})\n      ]),\n      // Third element\n      h(\"div\", {style: gridItem}, [\n        h(\"div\", {style: fs.text, \"width\": \"300px\"}, [\n          h(\"p\", {style: {\"font-size\": \"25px\", \"margin-bottom\": \"10px\"}}, \"Simple standart\"),\n          h(\"p\", {}, \"Its reference implementation, including parser, stringifier, evaluator and type checker has about 1,000 lines of code. This is important to: \"),\n          h(\"p\", {style: {\"margin-top\": \"5px\"}}, \"1. Portability: we want Formality to be a library in many languages, just like JSON\"),\n          h(\"p\", {style: {\"margin-top\": \"5px\"}}, \"2. Trust: we don't want people to trust on a single, monolithic, bug-prone implementation\"),\n        ]),\n        h(\"img\", {src: _images_code_png__WEBPACK_IMPORTED_MODULE_3___default.a, alt: \"image3\", style: featureImg})\n      ])\n    ]);\n  }\n\n}\n\n// Content about how to use Formality\nclass Usage extends Component {\n  constructor(props) {\n    super(props)\n    this.state = {};\n  }\n\n  render() {\n    const usageContainer = {\n      ...s.bigContainer,\n      \"background-image\": \"url(src/images/usageBg2.png)\",\n      \"align-items\": \"center\",\n      \"justify-content\": \"center\",\n    }\n    \n    const usageCodeContainer = {\n      \"margin-top\": \"20px\",\n      \"heigth\": \"250px\",\n      \"width\" : \"600px\",\n      \"background-color\": s.secondaryColor,\n      \"flex-direction\": \"column\",\n      \"font-family\" : \"Inconsolata\", \n      \"font-size\" : \"15px\",\n      \"padding-top\": \"20px\",\n      \"padding-right\": \"20px\",\n      \"padding-bottom\": \"20px\",\n      \"padding-left\": \"20px\"\n    }\n\n    return h(\"div\", {style: s.usageContainer}, [\n      h(\"div\", {style: fs.title}, \"Usage\"),\n      h(\"div\", {style: fs.subtitle }, \"Formality is currently implemented as a small, dependency-free JavaScript library. It will futurely be implemented in other languages, and formalized in Agda/Coq. To use the current implementation:\"),\n      h(\"div\", {style: s.usageCodeContainer, \"margin-top\": \"50px\"}, [\n        h(\"p\", {style: {\"color\": '#6B747F' }}, \"# Installs Formality\"),\n        h(\"p\", {style: {\"color\": '#373D41' }}, \"npm i -g formality-lang\"),\n        h(\"br\", {}, \"     \"),\n        h(\"p\", {style: {\"color\": '#6B747F' }}, \"# Enters the repository\"),\n        h(\"p\", {style: {\"color\": '#373D41' }}, \"git clone https://github.com/maiavictor/formality\"),\n        h(\"p\", {style: {\"color\": '#373D41' }}, \"cd formality\"),\n        h(\"br\", {}, \"     \"),\n        h(\"p\", {style: {\"color\": '#6B747F' }}, \"# Checks and evaluates main\"),\n        h(\"p\", {style: {\"color\": '#373D41' }}, \"formality main\"),\n      ]),\n    ]);\n  }\n}\n\n// ============= Try it =============\nclass TryIt extends Component {\n  constructor(props){\n    super(props)\n    this.state = {currentCode: props.currentCode, title: \"First hi!!\"};\n  }\n\n  onClickExample(code){\n    this.setState({currentCode: code});\n    this.setState({title: \"title is know updated!!\"});\n  }\n\n  render(){\n    const container = {\n      \"display\": \"flex\",\n      \"flex-direction\": \"column\",\n      \"justify-content\": \"flex-start\",\n      \"align-items\": \"flex-start\",\n      \"height\": \"700px\",\n      \"margin-right\": \"200px\",\n      \"margin-left\": \"200px\",\n      \"font-family\": \"Open Sans\",\n      \"color\": \"#373530\"\n    }\n\n    const title = {\n      ...fs.title,\n      \"justify-content\": \"flex-start\",\n    }\n\n    const text = {\n      ...fs.text,\n      \"padding\": \"0px\",\n      \"margin-top\": \"20px\",\n    }\n\n  //   const subtitle = {\n  //     \"margin-top\": \"30px\",\n  //     \"margin-bottom\": \"10px\",\n  //     \"font-size\": \"23px\",\n  //     \"font-family\": \"Open Sans\",\n  //     \"color\": s.primaryColor, \n  //   }\n\n  //   const codeHelloWorld = ` .main (Hello World)`\n\n  //   const codeIdentity = `\n  // .ID\n  // : {x : Type} Type\n  // = [x] x\n\n  // .main\n  //   (ID Type) \n  //   `\n\n    return h(\"div\", {style: container}, [\n      h(\"p\", {style: title}, \"Online editor\"),\n      h(\"p\", {style: text}, [\n        h(\"span\", {}, \"You can read more about Formality type system \"),\n        h(InternalLink, {title: \"here \"}), // TODO: add link\n        h(\"span\", {}, \"and its installation \"),\n        h(InternalLink, {title: \"here \"}), // TODO: add link\n      ]),\n      h(Terminal)\n      // console.log(\"1. Rendering with the code: \"+this.state.currentCode),\n      // console.log(\"2. Title props: \"+this.state.title),\n      // h(Terminal, {currentCode: this.state.currentCode, title: this.props.title}),\n      // h(\"p\", {style: subtitle}, \"Check out some examples:\"),\n      // h(\"div\", {}, [ // TODO: add an expansible area to contain explanation about the examples      \n      //   h(\"p\", {style: {\"cursor\": \"pointer\"}, onClick: () => { this.onClickExample(codeHelloWorld) }}, \"1. Hello World\"),\n      //   h(\"p\", {style: {\"cursor\": \"pointer\"}, onClick: () => { this.onClickExample(codeIdentity) }}, \"2. Identity\"),\n      // ])\n    ] );\n  }\n}\n\nclass Terminal extends Component {\n  constructor(props){\n    super(props)\n    this.state = {currentCode: props.currentCode, codeExample: props.codeExample, log: props.log, outputType: props.outputType, title: props.title};\n  }\n\n  componentDidUpdate(newProps) {\n    // this.setState({currentCode: this.state.currentCode})\n    // console.log(\">> Comp did Update. Current code: \"+ this.state.currentCode);\n    // console.log(\"> and title: \"+this.props.title)\n  }\n  // Get a string and tranform it into a Formality code. \n  // Then, executes an action to compute the normal form or check the type of the code\n  runCode(actionType) {\n    const code = this.state.currentCode;\n    if (code !== undefined) {\n      if (!(code.includes(\".main\") || code.includes(\". main\"))) {\n        this.setState({log: \"The code must include a '.main' statement. You can check some examples to see how it works :D\"})\n      } else {\n        const log = actionType === \"run\" ? \"Normal form: \" : \"Check type: \";\n        this.setState({outputType: log});\n        try {\n          const defs = f.parse(this.state.currentCode); // gets a String and transform it into Formality code\n          const result = actionType === \"run\" ? f.norm(f.Ref(\"main\"), defs) : f.infer(f.Ref(\"main\"), defs);\n          this.setState({log: f.show(result)});\n        } catch (e) { // Compiler errors\n          this.setState({log: e});\n        }\n      }\n    } else {\n      this.setState({log: \"Type some code to run it or try some of our examples :D\"})\n    }\n  }\n\n  // Update the currentState with the user's input\n  handleInput(event) {\n    this.setState({currentCode: event.target.value});\n  }\n\n  // Must override the code type by the user\n  onClickExample(code) {\n    this.setState({currentCode: code});\n  }\n\n  render() {\n    const container = {\n      \"margin-top\": \"30px\",\n      \"display\": \"flex\",\n      \"flex-direction\": \"column\",\n      \"justify-content\": \"flex-start\",\n      \"align-items\": \"flex-start\",\n      \"height\": \"700px\",\n      \"width\": \"100%\",\n    }\n    const containerTerminal = {\n      \"display\": \"flex\",\n      \"flex-direction\": \"column\",\n      \"justify-content\": \"flex-start\",\n      \"align-items\": \"flex-start\",\n      \"height\": \"500px\",\n      \"width\": \"100%\",\n      \"border-style\": \"solid\",\n      \"border-color\": \"#979797\",\n      \"border-width\": \"1px\"\n    }\n\n    const topBar = {\n      \"display\": \"flex\",\n      \"flex-direction\": \"row\",\n      \"justify-content\": \"flex-end\",\n      \"height\": \"40px\",\n      \"width\": \"100%\",\n      \"border-color\": \"#979797\",\n      \"border-width\": \"1px\",\n      \"align-items\": \"center\",\n    }\n\n    const codeArea = {\n      \"display\": \"flex\",\n      \"flex-direction\": \"row\",\n      \"justify-content\": \"flex-start\",\n      \"width\": \"100%\",\n      \"border-style\": \"solid none none none\",\n      \"border-color\": \"#979797\",\n      \"border-width\": \"1px\",\n      \"font-family\": \"Inconsolata\",\n      \"font-size\" : \"15px\",\n    }\n    const input = {\n      ...codeArea,\n      \"height\": \"500px\",\n    }\n    const output = {\n      ...codeArea,\n      \"height\": \"100px\"\n    }\n    const textArea = {\n      \"outline\": \"none\", \n      \"resize\": \"none\", \n      \"width\": \"100%\",\n      \"height\": \"310px\",\n      \"margin\": \"5px\",\n      \"font-family\": \"Inconsolata\",\n      \"font-size\" : \"15px\",\n      \"border-width\": \"0px\",\n    }\n\n    const subtitle = {\n      \"margin-top\": \"30px\",\n      \"margin-bottom\": \"10px\",\n      \"font-size\": \"23px\",\n      \"font-family\": \"Open Sans\",\n      \"color\": s.primaryColor, \n    }\n    const codeHelloWorld = ` .main (Hello World)`\n\n    const codeIdentity = `\n  .ID\n  : {x : Type} Type\n  = [x] x\n\n  .main\n    (ID Type) \n    `\n\n    return h(\"div\", {style: container}, [\n    h(\"div\", {style: containerTerminal}, [\n      // Header with buttons\n      h(\"div\", {style: topBar}, [\n        h(TerminalButton, {title: \"Run\", onClick: () => { this.runCode(\"run\") }}),\n        h(TerminalButton, {title: \"Check\", onClick: () => { this.runCode() }}),\n      ]), \n      // Code input\n      h(\"div\", {style: input}, [\n        h(\"textarea\", { \"outline\": \"none\", \"resize\": \"none\", \"placeholder\": \"Type your code or try some of our examples\", \n        style: textArea, \"value\": this.state.currentCode,\n        onchange: this.handleInput.bind(this)}, this.state.currentCode),\n      ]),\n      // Log output\n      h(\"div\", {style: output}, [\n        h(\"p\", {style: {\"margin-left\": \"10px\"}}, [\n          h(\"p\", {}, this.state.outputType),\n          h(\"p\", {}, this.state.log),\n        ])\n      ])\n    ]),\n    h(\"p\", {style: subtitle}, \"Check out some examples:\"),\n      h(\"div\", {style: {\"color\": s.primaryColor}}, [ // TODO: add an expansible area to contain explanation about the examples      \n        h(\"p\", {style: {\"cursor\": \"pointer\"}, onClick: () => { this.onClickExample(codeHelloWorld) }}, \"1. Hello World\"),\n        h(\"p\", {style: {\"cursor\": \"pointer\"}, onClick: () => { this.onClickExample(codeIdentity) }}, \"2. Identity\"),\n      ])\n    ]);\n  }\n}\n\n// Receive the Terminal.state.currentCode, execute it and updates Terminal.state.log \nclass TerminalButton extends Component {\n  constructor(props){\n    super(props)\n    this.onClick = props.onClick;\n    this.title = props.title;\n  }\n\n  render(){\n    const style = {\n      \"cursor\": \"pointer\",\n      \"width\": \"40px\",\n      \"margin-right\": \"20px\",\n    }\n    const onFocusStyle = {\n      ... style,\n      \"color\": \"#8091A5\"\n    }\n    // TODO: create a tooltip to help people understands what each button means\n    return h(Hover, {normalComponent: h(\"div\", {style: style, onClick: this.onClick}, this.props.title),\n                    onFocusComponent: h(\"div\", {style: onFocusStyle, onClick: this.onClick}, this.props.title),});\n  }\n}\n\n// ============= Overview =============\nclass Overview extends Component {\n  constructor(props) {\n    super(props)\n    this.state = {page: props.page};\n  }\n  isCurrentPage(id) {\n    return this.state.page === id;\n  }\n\n  render(){\n    const contentNavigator = \n      h(ContentNavigatorContainer, {items: [\n        h(ContentNavigatorItem, {title: \"LEARNING\", isMainTopic: true}),\n        h(ContentNavigatorItem, {title: \"Getting started\", onClick: () => {\n          if (this.state.page !== pageOVGettingStarted) {\n            this.setState({ page: pageOVGettingStarted });\n            history.pushState({ page: pageOVGettingStarted }, \"/\"+pageOVGettingStarted, \"/\"+pageOVGettingStarted);\n          }\n        }, isCurrentPage: this.isCurrentPage(pageOVGettingStarted)}),\n        h(ContentNavigatorItem, {title: \"Examples\", onClick: () => {\n          if (this.state.page !== pageExamples) {\n            this.setState({ page: pageExamples });\n            history.pushState({ page: pageExamples }, \"/\"+pageExamples, \"/\"+pageExamples);\n          }\n        }, isCurrentPage: this.isCurrentPage(pageOVFAQ)}),\n        h(ContentNavigatorItem, {title: \"FAQ\", onClick: () => {\n          if (this.state.page !== pageOVFAQ) {\n            this.setState({ page: pageOVFAQ });\n            history.pushState({ page: pageOVFAQ }, \"/\"+pageOVFAQ, \"/\"+pageOVFAQ);\n          }\n        }, isCurrentPage: this.isCurrentPage(pageOVFAQ)}),\n        h(ContentNavigatorItem, {title: \"CONTEXT\", isMainTopic: true}),\n        h(ContentNavigatorItem, {title: \"Interaction Combinators\"}),\n        h(ContentNavigatorItem, {title: \"Elementary Affine Calculus\"}),\n        h(ContentNavigatorItem, {title: \"ESCoC\"}),\n      ]});\n\n    const contentNavigatorStyle = {\n      \"margin-left\": \"200px\", \n      \"margin-right\": \"200px\", \n      \"margin-top\": \"60px\",\n      \"display\": \"flex\",\n      \"flex-direction\": \"row\",\n      \"justify-content\": \"flex-start\",\n    }\n    // ------ Rendering the content for each element on Content Navigator ------\n    if (this.state.page === pageOverview) {\n      return h(\"div\", {style: contentNavigatorStyle}, [\n        contentNavigator,\n        h(\"p\", {}, \"I'm the first Overview!\")\n      ]);\n    } else if (this.state.page === pageOVGettingStarted) {\n      return h(\"div\", {style: contentNavigatorStyle}, [\n        contentNavigator,\n        h(DocsMarkdownContainer, {mdResource: ovGettingStartedMD})   \n      ]);\n    } else if (this.state.page === pageExamples) {\n      console.log(\"Rendering pageExamples\");\n      return h(\"div\", {style: contentNavigatorStyle}, [\n        contentNavigator,\n        h(DocsMarkdownContainer, {mdResource: ovExamplesMD}) \n      ]);\n    } else if (this.state.page === pageOVFAQ) {\n      return h(\"div\", {style: contentNavigatorStyle}, [\n        contentNavigator,\n        h(DocsMarkdownContainer, {mdResource: ovFAQMD})\n      ]);\n    }\n    \n  }\n}\n\n\n// Footer with a purple line on top of it. Used for pages that is not Home\nclass FooterContainer extends Component {\n  constructor(props) {\n    super(props)\n    this.state = {};\n  }\n\n  render() {\n    return h(\"div\", {style: {'flex-direction': 'row'}}, [\n             h(\"div\", {style: {\"background-color\": s.primaryColor, \"height\": \"1px\"}}),\n             h(Footer, {}),\n           ])\n  }\n}\n\nclass Footer extends Component {\n  constructor(props) {\n    super(props)\n    this.state = {};\n  }\n\n  render() {\n    const footerContainer = {\n      \"display\": \"flex\",\n      \"margin-top\": \"20px\",\n      \"margin-left\": \"200px\",\n      \"font-size\": \"13px\",\n      \"font-family\": \"Open Sans\",\n      \"color\": s.primaryColor,\n      \"flex-direction\": \"row\",\n      \"justify-content\": \"space-between\",\n      \"background-color\": s.secondaryColor,\n      \"height\": \"100px\",\n      \"width\": \"600px\",\n    }\n\n    const githubIcon = {\n      \"width\" : \"20px\",\n      \"height\" : \"20px\",\n      \"margin-top\" : \"5px\", \n      \"cursor\": \"pointer\"\n    }\n\n    return h(\"div\", {style: footerContainer}, [\n      h(\"div\", {}, [\n        h(\"p\", {}, \"Talk to us \"),\n        h(\"p\", {}, \"(soon...) \"),\n      ]),\n      h(\"div\", {}, [\n        h(\"p\", {}, \"Community\"),\n        h('span', {}, [\n          h('a', {'href': 'https://github.com/moonad/Formality', 'text-decoration': 'none',}, h(\"img\", {src: _images_github_png__WEBPACK_IMPORTED_MODULE_5___default.a, alt: \"logo\", style: githubIcon}),),\n        ])\n      ]),\n      h('div', {style: {'flex-direction': 'column'}}, [\n        h('p', {}, [\n          h('span', {}, \"Landing images by \"),\n          h('span', {}, [\n            h('a', {'href': 'https://undraw.co', style: {'color': '#68c3d4', 'text-decoration': 'none'}}, \"unDraw\"),\n          ])\n        ]),\n        h('p', {style: {'margin-top': '5px'}}, [\n          h('span', {}, \"Background photo by Paul Earle on \"),\n          h('span', {}, [\n            h('a', {'href': 'https://unsplash.com/photos/wVjd0eWNqI8', style: {'color': '#68c3d4', 'text-decoration': 'none'} }, \"Unsplash\"),\n          ])\n        ])\n      ]),\n    ],\n    );\n  }\n}\n\n\nwindow.onload = () => {\n  render(h(\"div\", {}, [h(Site)]), document.getElementById(\"main\"));\n};\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/markdown/overview/1.GettingStarted.js":
/*!***************************************************!*\
  !*** ./src/markdown/overview/1.GettingStarted.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const h = __webpack_require__(/*! inferno-hyperscript */ \"./node_modules/inferno-hyperscript/dist/index.esm.js\").h;\nmodule.exports = [\n[\n  h('h1', {style: {'margin-top': '20px'}}, \n    [\n      \"Get started\"\n    ]\n  ),\n  h('p', \n    [\n      \"To install Formality\",\n      \", you must have npm\",\n      \". Once you do\",\n      \", just type\",\n      \":\"\n    ]\n  ),\n  h('pre', {style: {'margin-top': '20px', 'margin-bottom': '20px', 'background-color': '#F6F8FA', 'padding': '15px'}}, [\n    h('code.bash', {style: {'font-size': '15px'}},\n      \"npm i -g formality-lang\"\n    )\n  ]),\n  h('p', \n    [\n      \"Now you can create a file with the extension \",\n      h('code', {style: {'font-size': '15px'}},'.fm'),\n      \" and execute it using\"\n    ]\n  ),\n  h('pre', {style: {'margin-top': '20px', 'margin-bottom': '20px', 'background-color': '#F6F8FA', 'padding': '15px'}}, [\n    h('code.bash', {style: {'font-size': '15px'}},\n      \"formality -n (file_name)\"\n    )\n  ]),\n  h('p', \n    [\n      \"Then youre good to go\",\n      \". Optionally\",\n      \", you can also use it as a JS library or\",\n      \", if you dont want to download anything\",\n      \", you can try our online editor \",\n      h('a', {href: 'localhost:3004/tryIt', style: {'color': '#0769D7', 'text-decoration': 'none'}},  \n        [\n          \"here\"\n        ]\n      ),\n      \".\"\n    ]\n  )\n]\n]\n\n//# sourceURL=webpack:///./src/markdown/overview/1.GettingStarted.js?");

/***/ }),

/***/ "./src/markdown/overview/2.Examples.js":
/*!*********************************************!*\
  !*** ./src/markdown/overview/2.Examples.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const h = __webpack_require__(/*! inferno-hyperscript */ \"./node_modules/inferno-hyperscript/dist/index.esm.js\").h;\nmodule.exports = \n[\n  h('h1', {style: {'margin-top': '25px'}}, \n    [\n      \"Examples\"\n    ]\n  ),\n  h('p', {style: {'margin-top': '5px'}}, \n    [\n      \"Assure you have Formality and npm installed on your computer or use our \",\n      h('a', {href: '', style: {'color': '#0769D7', 'text-decoration': 'none'}},  \n        [\n          \"online editor\"\n        ]\n      ),\n      \".\"\n    ]\n  ),\n  h('p', {style: {'margin-top': '5px'}}, \n    [\n      \"For all the examples\",\n      \", use \",\n      \".fm file\",\n      \". You can run them on the same directory that is your file using\",\n      \":\"\n    ]\n  ),\n  h('ul', {style: {'margin-left': '23px'}}, [\n    h('li', {style: {'margin-top': '7px'}}, \n      [\n        h('p', {style: {'margin-top': '5px'}}, \n          [\n            h('code', {style: {'font-size': '15px', 'background-color': '#F6F8FA'}}, `formality -n main`),\n            \": computes the normal form\"\n          ]\n        )\n      ]\n    ),\n    h('li', {style: {'margin-top': '7px'}}, \n      [\n        h('p', {style: {'margin-top': '5px'}}, \n          [\n            h('code', {style: {'font-size': '15px', 'background-color': '#F6F8FA'}}, `formality -inN main`),\n            \": \",\n            \"-N \",\n            \"(uppercase\",\n            \") flag tells it to show the normal of the type\",\n            \", and the \",\n            \"-i flag tells it to show the titles\",\n            \".\"\n          ]\n        )\n      ]\n    ),\n  ]),\n  h('p', {style: {'margin-top': '5px'}}, \n    [\n      h('b', \n        [\n          \"Important\"\n        ]\n      ),\n      \": \"\n    ]\n  ),\n  h('ul', {style: {'margin-left': '23px'}}, [\n    h('li', {style: {'margin-top': '7px'}}, \n      [\n        h('code', {style: {'font-size': '15px', 'background-color': '#F6F8FA'}}, `formality -n main`),\n        \" reads all \",\n        \".fm files on the current directory and loads the definitions inside them\",\n        \". The \",\n        h('code', {style: {'font-size': '15px', 'background-color': '#F6F8FA'}}, `-n main`),\n        \" bit means it must eval the main definition and output the result\"\n      ]\n    ),\n  ]),\n  h('h2', {style: {'margin-top': '20px'}}, \n    [\n      \"1\",\n      \". Hello World\"\n    ]\n  ),\n  h('pre', {style: {'margin-top': '10px', 'margin-bottom': '10px', 'padding': '20px', 'background-color': '#F6F8FA'}}, [\n    h('code.bash', {style: {'font-size': '15px'}}, \n      \".main (hello world)\"\n    )\n  ]),\n  h('p', {style: {'margin-top': '5px'}}, \n    [\n      \"Output\",\n      \":\"\n    ]\n  ),\n  h('pre', {style: {'margin-top': '10px', 'margin-bottom': '10px', 'padding': '20px', 'background-color': '#F6F8FA'}}, [\n    h('code.bash', {style: {'font-size': '15px'}}, \n      \"(hello world)\"\n    )\n  ]),\n  h('h2', {style: {'margin-top': '20px'}}, \n    [\n      \"2\",\n      \". Identity\"\n    ]\n  ),\n  h('pre', {style: {'margin-top': '10px', 'margin-bottom': '10px', 'padding': '20px', 'background-color': '#F6F8FA'}}, [\n    h('code.bash', {style: {'font-size': '15px'}}, \n      \".id [x] x\\n.main \\n  (id 42)\"\n    )\n  ]),\n  h('p', {style: {'margin-top': '5px'}}, \n    [\n      \"Output\",\n      \":\"\n    ]\n  ),\n  h('pre', {style: {'margin-top': '10px', 'margin-bottom': '10px', 'padding': '20px', 'background-color': '#F6F8FA'}}, [\n    h('code.bash', {style: {'font-size': '15px'}}, \n      \"(id 42)\"\n    )\n  ]),\n  h('p', {style: {'margin-top': '5px'}}, \n    [\n      \"Note that\",\n      \", here\",\n      \", 42 is not an actual number\",\n      \", but an undefined reference\",\n      \". Well give meaning to it later\",\n      \".\"\n    ]\n  ),\n  h('h2', {style: {'margin-top': '20px'}}, \n    [\n      \"3\",\n      \". Copy\"\n    ]\n  ),\n  h('pre', {style: {'margin-top': '10px', 'margin-bottom': '10px', 'padding': '20px', 'background-color': '#F6F8FA'}}, [\n    h('code.bash', {style: {'font-size': '15px'}}, \n      \".id [x] x\\n.main [val = id] (val val)\"\n    )\n  ]),\n  h('p', {style: {'margin-top': '5px'}}, \n    [\n      \"This program makes a copy of \",\n      h('code', {style: {'font-size': '15px', 'background-color': '#F6F8FA'}}, `id`),\n      \" and applies it to itself\",\n      \". The result should be just \",\n      h('code', {style: {'font-size': '15px', 'background-color': '#F6F8FA'}}, `id`),\n      \", i\",\n      \".e\",\n      \".\",\n      \", \",\n      h('code', {style: {'font-size': '15px', 'background-color': '#F6F8FA'}}, `[x] x`),\n      \", but\",\n      \", if we run it with \",\n      h('code', {style: {'font-size': '15px', 'background-color': '#F6F8FA'}}, `formality -n main`),\n      \", it outputs\",\n      \":\"\n    ]\n  ),\n  h('pre', {style: {'margin-top': '10px', 'margin-bottom': '10px', 'padding': '20px', 'background-color': '#F6F8FA'}}, [\n    h('code.bash', {style: {'font-size': '15px'}}, \n      \"[val = [x] x] (val val)\"\n    )\n  ]),\n  h('p', {style: {'margin-top': '5px'}}, \n    [\n      \"As you can see\",\n      \", the copy doesnt happen \",\n      \"(obs\",\n      \": how can I see the reason why it doesn\",\n      \"'t happen\",\n      \"?\",\n      \"?\",\n      \")\",\n      \". Thats because id wasnt \",\n      h('a', {href: '', style: {'color': '#0769D7', 'text-decoration': 'none'}},  \n        [\n          \"boxed\"\n        ]\n      ),\n      \". We can fix it by putting it in a box with a pipe \",\n      \"(\",\n      \"|\",\n      \")\",\n      \":\"\n    ]\n  ),\n  h('pre', {style: {'margin-top': '10px', 'margin-bottom': '10px', 'padding': '20px', 'background-color': '#F6F8FA'}}, [\n    h('code.bash', {style: {'font-size': '15px'}}, \n      \".main [val = | id] (val val)\"\n    )\n  ]),\n  h('p', {style: {'margin-top': '5px'}}, \n    [\n      \"And now this works as expected\",\n      \"! But this is still not legal\",\n      \", though\",\n      \", because there isnt exactly 1 box between where val is bound and where it is used\",\n      \". This can be easily fixed\",\n      \":\"\n    ]\n  ),\n  h('pre', {style: {'margin-top': '10px', 'margin-bottom': '10px', 'padding': '20px', 'background-color': '#F6F8FA'}}, [\n    h('code.bash', {style: {'font-size': '15px'}}, \n      \".id [x] x\\n.main [val = id] | (val val)\\n// Outputs\\n// [val = [x] x] |(val val)\"\n    )\n  ]),\n  h('div', {style: {'margin-top': '25px', 'margin-bottom': '25px', 'margin-left': '20px', 'margin-right': '20px', 'color': '#6B737F', 'font-style': 'italic' }}, \n    [\n      h('p', {style: {'margin-top': '5px'}}, \n        [\n          \"A very insightful exercise must be to follow a standard lambda calculus tutorial\",\n          \", except using that language instead\",\n          \".\"\n        ]\n      )\n    ]\n  ),\n  h('h2', {style: {'margin-top': '20px'}}, \n    [\n      \"4\",\n      \". Simple data types\"\n    ]\n  ),\n  h('p', {style: {'margin-top': '5px'}}, \n    [\n      \" Let\",\n      \"'s take for example this data types on Agda\",\n      \":\"\n    ]\n  ),\n  h('pre', {style: {'margin-top': '10px', 'margin-bottom': '10px', 'padding': '20px', 'background-color': '#F6F8FA'}}, [\n    h('code.bash', {style: {'font-size': '15px'}}, \n      \"-- A new datatype\\ndata Bool : Set where\\n  true  : Bool\\n  false : Bool\\n\\n-- Its elimination principle\\nif : (b : Bool) (P : Bool -> Set) -> P true -> P false -> P b\\nif true  P t f = t\\nif false P t f = f\\n\\n-- Functions using it\\nnot : Bool -> Bool\\nnot a = if a ( x  Bool) false true\\n\\nand : Bool -> Bool -> Bool\\nand a b = if a ( a  Bool) b false\\n\\nor : Bool -> Bool -> Bool\\nor a b = if a ( a  Bool) true b\"\n    )\n  ]),\n  h('p', {style: {'margin-top': '5px'}}, \n    [\n      \"Here is how the same program is translated to Formality\",\n      \":\"\n    ]\n  ),\n  h('pre', {style: {'margin-top': '10px', 'margin-bottom': '10px', 'padding': '20px', 'background-color': '#F6F8FA'}}, [\n    h('code.bash', {style: {'font-size': '15px'}}, \n      \". Bool\\n: Type\\n= $self\\n  {-P    : {:Bool} Type}\\n  {true  : (P true)}\\n  {false : (P false)}\\n  (P self)\\n\\n. true\\n: Bool\\n= @Bool [-P] [t] [f] t\\n\\n. false\\n: Bool\\n= @Bool [-P] [t] [f] f\\n\\n. if\\n: {a : Bool} {-P : {:Bool} Type} {:(P true)} {:(P false)} (P a)\\n= [a] ~a\\n\\n. not\\n: {a : Bool} Bool\\n= [a] (if a -[a]Bool false true)\\n\\n. or \\n: {a : Bool} {b : Bool} Bool\\n= [a] [b] (if a -[a]Bool true b)\\n\\n. and \\n: {a : Bool} {b : Bool} Bool\\n= [a] [b] (if a -[a]Bool b false)\\n\\n. main\\n  (not true)\"\n    )\n  ]),\n  h('p', {style: {'margin-top': '5px'}}, \n    [\n      h('b', \n        [\n          \"Don\",\n          \"'t panic\",\n          \"!\"\n        ]\n      ),\n      \" Studying this example is the best way to grasp it\",\n      \". Spend some time on it until this makes sense to you\",\n      \"! \",\n      \":D\"\n    ]\n  ),\n  h('p', {style: {'margin-top': '5px'}}, \n    [\n      h('b', \n        [\n          \"Things worth noting\",\n          \":\"\n        ]\n      )\n    ]\n  ),\n  h('ol', {style: {'margin-left': '23px'}}, [\n    h('li', {style: {'margin-top': '7px'}}, \n      [\n        h('p', {style: {'margin-top': '5px'}}, \n          [\n            \"Notice how similar it is to Agdas \",\n            h('code', {style: {'font-size': '15px', 'background-color': '#F6F8FA'}}, `if`),\n            \"? Thats because Formality datatypes are simply Agdas elimination principles for that datatype\",\n            \", except with self used on the first and last lines\",\n            \"!\"\n          ]\n        )\n      ]\n    ),\n    h('li', {style: {'margin-top': '7px'}}, \n      [\n        h('p', {style: {'margin-top': '5px'}}, \n          [\n            \"The lambda binding \",\n            h('code', {style: {'font-size': '15px', 'background-color': '#F6F8FA'}}, `-P`),\n            \" is erased to avoid unnecessary runtime costs\",\n            \".\"\n          ]\n        )\n      ]\n    ),\n    h('li', {style: {'margin-top': '7px'}}, \n      [\n        h('p', {style: {'margin-top': '5px'}}, \n          [\n            \"Both \",\n            h('code', {style: {'font-size': '15px', 'background-color': '#F6F8FA'}}, `true`),\n            \" and \",\n            h('code', {style: {'font-size': '15px', 'background-color': '#F6F8FA'}}, `false`),\n            \" must be declared explicitly because\",\n            \", unlike Agdas native data syntax\",\n            \", our \",\n            h('code', {style: {'font-size': '15px', 'background-color': '#F6F8FA'}}, `Bool`),\n            \" definition wont automatically define them\",\n            \".\"\n          ]\n        )\n      ]\n    ),\n    h('li', {style: {'margin-top': '7px'}}, \n      [\n        h('p', {style: {'margin-top': '5px'}}, \n          [\n            h('code', {style: {'font-size': '15px', 'background-color': '#F6F8FA'}}, `$self ...`),\n            \" is used to define an inductive datatype \",\n            h('code', {style: {'font-size': '15px', 'background-color': '#F6F8FA'}}, `T`),\n            \", and \",\n            h('code', {style: {'font-size': '15px', 'background-color': '#F6F8FA'}}, `@T ...`),\n            \" is used to instantiate each of its constructors\",\n            \".\"\n          ]\n        )\n      ]\n    ),\n    h('li', {style: {'margin-top': '7px'}}, \n      [\n        h('p', {style: {'margin-top': '5px'}}, \n          [\n            \"The type of \",\n            h('code', {style: {'font-size': '15px', 'background-color': '#F6F8FA'}}, `Bool`),\n            \" refers to \",\n            h('code', {style: {'font-size': '15px', 'background-color': '#F6F8FA'}}, `true`),\n            \", which refers to \",\n            h('code', {style: {'font-size': '15px', 'background-color': '#F6F8FA'}}, `Bool`),\n            \", in a mutually recursive fashion\",\n            \". This is clearly necessary\",\n            \", because inductive datatypes are defined as their own elimination principles\",\n            \", which refer to their constructors\",\n            \", which are members of those types\",\n            \", and so on\",\n            \"! Yet\",\n            \", this kind of type\",\n            \"-level recursion isnt capable of causing infinite loops because\",\n            \", remember\",\n            \", Formalitys termination proof doesnt rely on types\",\n            \".\"\n          ]\n        )\n      ]\n    ),\n    h('li', {style: {'margin-top': '7px'}}, \n      [\n        h('p', {style: {'margin-top': '5px'}}, \n          [\n            \"We give an explicit annotation to all the terms because\",\n            \", due to the cyclic dependency above\",\n            \", Formality wouldnt be able to infer their types\",\n            \".\"\n          ]\n        )\n      ]\n    ),\n  ]),\n  h('p', {style: {'margin-top': '5px'}}, \n    [\n      \"Once that makes sense to you\",\n      \", the rest is straightforward\",\n      \". Since datatypes are encoded as their elimination principles\",\n      \", in order to get them you must just eliminate their self types with a \",\n      h('code', {style: {'font-size': '15px', 'background-color': '#F6F8FA'}}, `~`),\n      \", which can be seen on the body of \",\n      h('code', {style: {'font-size': '15px', 'background-color': '#F6F8FA'}}, `if`),\n      \". After the bureaucracy of defining a new datatype is complete\",\n      \", functions that operate on them are basically direct\",\n      \", syntactical translation of their Agda counterparts\",\n      \"!\"\n    ]\n  )\n]\n\n//# sourceURL=webpack:///./src/markdown/overview/2.Examples.js?");

/***/ }),

/***/ "./src/markdown/overview/3.FAQ.js":
/*!****************************************!*\
  !*** ./src/markdown/overview/3.FAQ.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const h = __webpack_require__(/*! inferno-hyperscript */ \"./node_modules/inferno-hyperscript/dist/index.esm.js\").h;\nmodule.exports = \n[\n  h('h1', {style: {'margin-top': '25px'}}, \n    [\n      \"FAQ\"\n    ]\n  ),\n  h('h3', {style: {'margin-top': '15px'}}, \n    [\n      h('b', \n        [\n          \"What Formality aims to be\",\n          \"?\"\n        ]\n      )\n    ]\n  ),\n  h('p', {style: {'margin-top': '5px'}}, \n    [\n      \"Formality aims to to be both a general\",\n      \"-purpose programming language\",\n      \", in the sense it can be used to build algorithms\",\n      \", applications\",\n      \", smart\",\n      \"-contracts and anything else\",\n      \", not unlike Python\",\n      \", JavaScript and similars\",\n      \", and a proof language\",\n      \", in the sense it can express and prove mathematical theorems about its own programs\",\n      \", not unlike Agda\",\n      \", Idris and Coq\",\n      \".\"\n    ]\n  ),\n  h('h3', {style: {'margin-top': '15px'}}, \n    [\n      h('b', \n        [\n          \"What is the difference between Formality and other proof languages like Agda\",\n          \", Coq and Idris\",\n          \"?\"\n        ]\n      )\n    ]\n  ),\n  h('p', {style: {'margin-top': '5px'}}, \n    [\n      \"Formality has two main differences due to its planned usage in the context of Smart\",\n      \"-Contracts\",\n      \".\"\n    ]\n  ),\n  h('ol', {style: {'margin-left': '23px'}}, [\n    h('li', {style: {'margin-top': '7px'}}, \n      [\n        \"It aims to be not just a single implementation\",\n        \", but also a well\",\n        \"-documented\",\n        \", minimalist specification which can be used by developers to implement it independently without much effort\",\n        \". This is important\",\n        \", because it removes the need for users to trust in a single\",\n        \", big \",\n        \"\\\"official implementation\",\n        \"\\\"\",\n        \". For comparison purposes\",\n        \", the current reference implementation of Formality has only 500 lines of code\",\n        \", while Coq\",\n        \"'s core has \",\n        \", Idris has \",\n        \", and Agda has \",\n        \"<\",\n        \"?\",\n        \"?\",\n        \"?\",\n        \">\",\n        \".\"\n      ]\n    ),\n    h('li', {style: {'margin-top': '7px'}}, \n      [\n        \"It is built from the beginning with efficiency as a priority\",\n        \". That means it includes a series of restrictions that make it more compatible with NASIC and\",\n        \", thus\",\n        \", more lightweight and faster than other proof languages\",\n        \", allowing its programs to run in architectures where performance is essential\",\n        \". This includes\",\n        \", for example\",\n        \", Smart\",\n        \"-Contracts\",\n        \", where each operation has a monetary cost\",\n        \", or even graphics and scientific applications\",\n        \", which usually run in massively parallel architectures such as the GPU\",\n        \".\"\n      ]\n    ),\n  ]),\n  h('h3', {style: {'margin-top': '15px'}}, \n    [\n      h('b', \n        [\n          \"What is NASIC\",\n          \"?\"\n        ]\n      )\n    ]\n  ),\n  h('p', {style: {'margin-top': '5px'}}, \n    [\n      \"NASIC is short for N\",\n      \"-Ary Symmetric Interaction Combinators\",\n      \", a graph\",\n      \"-based model of computation used as the main compile target for Formality\",\n      \". It has a similar role to ASM for C\",\n      \", or the STG for Haskell\",\n      \". Compared to those\",\n      \", it has very good computational properties\",\n      \":\"\n    ]\n  ),\n  h('ol', {style: {'margin-left': '23px'}}, [\n    h('li', {style: {'margin-top': '7px'}}, \n      [\n        \"It is inherently parallel\",\n        \", meaning you can reduce NASIC graphics in massively parallel architectures like the GPU\",\n        \".\"\n      ]\n    ),\n    h('li', {style: {'margin-top': '7px'}}, \n      [\n        \"It is strongly confluent\",\n        \", which gives us a very clear cost model for use\",\n        \"-cases like gas metering\",\n        \".\"\n      ]\n    ),\n    h('li', {style: {'margin-top': '7px'}}, \n      [\n        \"It can be used to implement optimal reductions for the \",\n        \"-calculus\",\n        \".\"\n      ]\n    ),\n  ]),\n  h('p', {style: {'margin-top': '5px'}}, \n    [\n      \"NASIC is based on\",\n      h('a', {href: 'https://pdfs.semanticscholar.org/1731/a6e49c6c2afda3e72256ba0afb34957377d3.pdf', style: {'color': '#0769D7', 'text-decoration': 'none'}},  \n        [\n          \"Symmetric Interaction Combinators\"\n        ]\n      ),\n      \", with two main changes\",\n      \":\"\n    ]\n  ),\n  h('ol', {style: {'margin-left': '23px'}}, [\n    h('li', {style: {'margin-top': '7px'}}, \n      [\n        \"Instead of only two node \",\n        \"\\\"labels\",\n        \"\\\" \",\n        \"( and \",\n        \")\",\n        \", nodes can be labelled with 32\",\n        \"-bit integers\",\n        \". This is what allows efficient evaluation of Formality programs through \",\n        \"\\\"boxes\",\n        \"\\\" and \",\n        \"\\\"levels\",\n        \"\\\"\",\n        \".\"\n      ]\n    ),\n    h('li', {style: {'margin-top': '7px'}}, \n      [\n        \"For simplicity\",\n        \", there isn\",\n        \"'t an erasure node\",\n        \". Instead\",\n        \", we use a fan node wired with each port wired to itself\",\n        \", which is equivalent\",\n        \".\"\n      ]\n    ),\n  ]),\n  h('h3', {style: {'margin-top': '15px'}}, \n    [\n      h('b', \n        [\n          \"What is the relationship between Formality and Cedille\",\n          \"?\"\n        ]\n      )\n    ]\n  ),\n  h('p', {style: {'margin-top': '5px'}}, \n    [\n      \"Cedille is a language invented by Aaron Stump that shares similar goals to Formality\",\n      \", in special minimalism\",\n      \". For a while\",\n      \",\",\n      h('a', {href: 'https://github.com/MaiaVictor/Cedille-Core', style: {'color': '#0769D7', 'text-decoration': 'none'}},  \n        [\n          \"Cedille\",\n          \"-Core\"\n        ]\n      ),\n      \"was actually planned to be used instead of Formality on Ethereum\",\n      \". Sadly\",\n      \", when trying to do so\",\n      \", I got stuck due to some problems which I explain\",\n      h('a', {href: 'https://medium.com/@maiavictor/towards-a-simple-theorem-prover-5005a1e66a6f', style: {'color': '#0769D7', 'text-decoration': 'none'}},  \n        [\n          \"in this article\"\n        ]\n      ),\n      \". This led me to design a new language\",\n      \",\",\n      h('a', {href: 'https://github.com/maiavictor/escoc', style: {'color': '#0769D7', 'text-decoration': 'none'}},  \n        [\n          \"ESCoC\"\n        ]\n      ),\n      \", which is better\",\n      \"-suited for my goals\",\n      \". Compared to Cedille\",\n      \"-Core\",\n      \", ESCoC is simpler to implement \",\n      \"(60\",\n      \"-70\",\n      \"% smaller\",\n      \")\",\n      \", simpler to use \",\n      \"(declaring datatypes take 60\",\n      \"-70\",\n      \"% less code\",\n      \")\",\n      \", and more compatible with NASIC\",\n      \". Formality is just a product name for ESCoC\",\n      \".\"\n    ]\n  ),\n  h('h3', {style: {'margin-top': '15px'}}, \n    [\n      h('b', \n        [\n          \"Why can\",\n          \"'t Formality be considered a proof language yet\",\n          \"?\"\n        ]\n      )\n    ]\n  ),\n  h('p', {style: {'margin-top': '5px'}}, \n    [\n      \"Because\",\n      \", unlike Cedille and Coq\",\n      \"'s core\",\n      \", we don\",\n      \"'t have a model for Formality yet\",\n      \". The language\",\n      \", as presented currently\",\n      \", is inconsistent and trivial\",\n      \", which means it can\",\n      \"'t be used as a proper proof language\",\n      \". It is perfectly fine as a programming language\",\n      \", though\",\n      \". In order to enable logical reasoning\",\n      \", we must identify a sound\",\n      \", consistent fragment of Formality\",\n      \", which is what we are doing right now\",\n      \".\"\n    ]\n  ),\n  h('h3', {style: {'margin-top': '15px'}}, \n    [\n      h('b', \n        [\n          \"What are the challenges for achieving consistency\",\n          \"?\"\n        ]\n      )\n    ]\n  ),\n  h('p', {style: {'margin-top': '5px'}}, \n    [\n      \"In order to derive inductive datatypes so succinctly\",\n      \", Formality must feature mutually recursive definitions\",\n      \". This\",\n      \", unfortunatelly\",\n      \", is known to introduce inconsistencies\",\n      \". Fortunatelly\",\n      \", though\",\n      \", the same set of restrictions required to make Formality compatible with NASIC has also\",\n      h('a', {href: 'http://www.kurims.kyoto-u.ac.jp/~terui/lastfin.pdf', style: {'color': '#0769D7', 'text-decoration': 'none'}},  \n        [\n          \"been proven\"\n        ]\n      ),\n      \"to be consistent with the presence of type\",\n      \"-level recursion\",\n      \". Our challenge is\",\n      \", thus\",\n      \", to formalize Formality and attempt to use the same idea to prove it is consistent under those restrictions\",\n      \".\"\n    ]\n  )\n]\n\n//# sourceURL=webpack:///./src/markdown/overview/3.FAQ.js?");

/***/ }),

/***/ "./src/markdown/test-template.md.js":
/*!******************************************!*\
  !*** ./src/markdown/test-template.md.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const h = __webpack_require__(/*! inferno-hyperscript */ \"./node_modules/inferno-hyperscript/dist/index.esm.js\").h;\nmodule.exports = [\n  h('h1', {style: {'margin-top': '20px'}}, \n    [\n      \"Formality\"\n    ]\n  ),\n  h('p', \n    [\n      \"A general\",\n      \"-purpose proof\",\n      \"-gramming language for front\",\n      \"-end apps\",\n      \", back\",\n      \"-end services and smart\",\n      \"-contracts\",\n      \". It is\",\n      \":\"\n    ]\n  ),\n  h('ul', {style: {'margin-left': '23px'}}, [\n    h('li', \n      [\n        h('p', \n          [\n            h('b', \n              [\n                \"Fast\",\n                \":\"\n              ]\n            ),\n            \" no garbage\",\n            \"-collection\",\n            \", \",\n            h('a', {href: 'https://medium.com/@maiavictor/solving-the-mystery-behind-abstract-algorithms-magical-optimizations-144225164b07', style: {'color': '#0769D7', 'text-decoration': 'none'}},  \n              [\n                \"optimal beta\",\n                \"-reduction\"\n              ]\n            ),\n            \" and a massively parallel GPU compiler make it \",\n            h('i', \n              [\n                \"insanely fast\"\n              ]\n            ),\n            \".\"\n          ]\n        )\n      ]\n    ),\n    h('li', \n      [\n        h('p', \n          [\n            h('b', \n              [\n                \"Safe\",\n                \":\"\n              ]\n            ),\n            \" a type system capable of proving mathematical theorems about its own programs make it \",\n            h('i', \n              [\n                \"really secure\"\n              ]\n            ),\n            \".\"\n          ]\n        )\n      ]\n    ),\n    h('li', \n      [\n        h('p', \n          [\n            h('b', \n              [\n                \"Simple\",\n                \":\"\n              ]\n            ),\n            \" its entire implementation takes \",\n            h('a', {href: 'javascript/formality.js', style: {'color': '#0769D7', 'text-decoration': 'none'}},  \n              [\n                \"<1k LOC\"\n              ]\n            ),\n            \", making it a simple standard \",\n            h('i', \n              [\n                \"you could implement yourself\"\n              ]\n            ),\n            \".\"\n          ]\n        )\n      ]\n    ),\n  ]),\n  h('h2', {style: {'margin-top': '15px'}}, \n    [\n      \"Usage\"\n    ]\n  ),\n  h('p', \n    [\n      \"Formality is currently implemented as a small\",\n      \", dependency\",\n      \"-free JavaScript library\",\n      \". It will futurely be implemented in other languages\",\n      \", and formalized in Agda\",\n      \"/Coq\",\n      \". To use the current implementation\",\n      \":\"\n    ]\n  ),\n  h('pre', {style: {'margin-top': '20px', 'margin-bottom': '20px', 'background-color': '#F6F8FA', 'padding': '15px'}}, [\n    h('code.bash', {style: {'font-size': '15px'}},\n      \"# Installs formality\\nnpm i -g formality\\n\\n# Enters the repository\\ngit clone https://github.com/maiavictor/formality\\ncd formality\\n\\n# Checks and evaluates main\\nformality main\"\n    )\n  ]),\n  h('p', \n    [\n      \"You can also use it as a library from your own JS code\",\n      \".\"\n    ]\n  )\n]\n\n//# sourceURL=webpack:///./src/markdown/test-template.md.js?");

/***/ }),

/***/ "./src/style.js":
/*!**********************!*\
  !*** ./src/style.js ***!
  \**********************/
/*! exports provided: formalityTitleContainer, primaryColor, secondaryColor, shadowBlue, linkColor, tabs, tabsOnFocus, topContainer, usageContainer, pageContentMD, usageCodeContainer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"formalityTitleContainer\", function() { return formalityTitleContainer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"primaryColor\", function() { return primaryColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"secondaryColor\", function() { return secondaryColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shadowBlue\", function() { return shadowBlue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"linkColor\", function() { return linkColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tabs\", function() { return tabs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tabsOnFocus\", function() { return tabsOnFocus; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"topContainer\", function() { return topContainer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"usageContainer\", function() { return usageContainer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pageContentMD\", function() { return pageContentMD; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"usageCodeContainer\", function() { return usageCodeContainer; });\n/* harmony import */ var _images_formality_bg_2_jpg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./images/formality-bg-2.jpg */ \"./src/images/formality-bg-2.jpg\");\n/* harmony import */ var _images_formality_bg_2_jpg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_images_formality_bg_2_jpg__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _images_usageBg2_png__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./images/usageBg2.png */ \"./src/images/usageBg2.png\");\n/* harmony import */ var _images_usageBg2_png__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_images_usageBg2_png__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _font_style__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./font-style */ \"./src/font-style.js\");\nconst primaryColor = \"#444053\";\nconst secondaryColor = \"#ffffff\";\nconst shadowBlue = \"#8091A5\";\nconst linkColor = \"#68c3d4\";\n\n\n\n\n\n\nconst formalityTitleContainer = {\n  \"width\": \"600px\",\n  \"height\": \"60px\",\n  \"object-fit\": \"cover\",\n  \"background-repeat\": \"no-repeat, repeat\",\n  \"background-size\": \"cover\",\n  \"display\": \"flex\",\n  \"flex-flow\": \"column nowrap\",\n  \"justify-content\": \"flex-start\",\n  \"align-items\": \"center\",\n}\n\nconst tabs = {\n  \"height\" : \"30px\", \n  \"margin\" : \"30px 20px 20px\",\n  \"display\" : \"flex\",\n  \"align-items\" : \"center\",\n  \"font-size\" : \"15px\",\n  \"font-family\" : \"Open Sans\"\n}\n\nconst tabsOnFocus = {\n  \"height\" : \"30px\", \n  \"margin\" : \"30px 20px 19px\",\n  \"border-bottom\" : \"1px solid #ffffff\",\n  \"display\" : \"flex\",\n  \"align-items\" : \"center\",\n  \"font-size\" : \"15px\",\n  \"font-family\" : \"Open Sans\",\n  \"cursor\": \"pointer\"\n}\n\nconst bigContainer = {\n  \"width\": \"100%\",\n  \"height\": \"650px\",\n  \"object-fit\": \"cover\",\n  \"background-repeat\": \"no-repeat, repeat\",\n  \"background-size\": \"cover\",\n  \"display\": \"flex\",\n  \"flex-direction\": \"column\",\n  \"flex-flow\": \"column nowrap\",\n  \"justify-content\": \"flex-start\",\n  \"align-items\": \"center\",\n}\n\nconst topContainer = {\n  ...bigContainer,\n  \"background-image\": \"url(src/images/formality-bg-2.jpg)\",\n}\n\nconst usageContainer = {\n  ...bigContainer,\n  \"background-image\": \"url(src/images/usageBg2.png)\",\n}\n\nconst usageCodeContainer = {\n  \"margin-top\": \"20px\",\n  \"heigth\": \"250px\",\n  \"width\" : \"600px\",\n  \"background-color\": secondaryColor,\n  \"flex-direction\": \"column\",\n  \"font-family\" : \"Inconsolata\", \n  \"font-size\" : \"15px\",\n  \"padding-top\": \"20px\",\n  \"padding-right\": \"20px\",\n  \"padding-bottom\": \"20px\",\n  \"padding-left\": \"20px\"\n}\n\nconst pageContentMD = {\n  \"font-family\": 'Open Sans', \n  \"color\": \"#373530\", \n  \"margin-left\": \"200px\", \n  \"margin-right\": \"200px\", \n  \"margin-top\": \"20px\", \n  \"line-height\": \"1.6\",\n}\n\n\n\n\n//# sourceURL=webpack:///./src/style.js?");

/***/ })

/******/ });